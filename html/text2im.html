
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>text2im</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-05-19"><meta name="DC.source" content="text2im.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>text2im</h1><!--introduction--><p><tt style="font-size:0%">Formatted documentation for the text2im function.</tt>
<div style="margin-top:-5em;color:grey">Generate an image from text (white text on black background).
</div>
</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li><li><a href="#2">Syntax</a></li><li><a href="#3">Output arguments</a></li><li><a href="#4">Input arguments</a></li><li><a href="#5">Fonts</a></li><li><a href="#6">Compatibility, version info, and licence</a></li><li><a href="#7">Test suite</a></li></ul></div><h2 id="1">Description</h2><p>
This function allows you to convert text to an image. There are several fonts you can pick, each
with their own character size.
<br>The list of included characters is based on a relatively arbitrary selection from three
Wikipedia pages: <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters">general
characters</a>, <a href="https://en.wikipedia.org/wiki/Newline#Unicode">newline characters</a>,
and <a href="https://en.wikipedia.org/wiki/Whitespace_character#Unicode>whitespace
characters</a>.
<br>The list of actually available characters depends on the chosen font.
</p><h2 id="2">Syntax</h2><pre class="language-matlab">imtext=text2im(text)
imtext=text2im(text,font)
</pre><h2 id="3">Output arguments</h2><p>
<table border=1>
<tr><td>
imtext
</td><td>
A char array containing the text image. The size is dependent on the font.
</td></tr>
</table>
</p><h2 id="4">Input arguments</h2><p>
<table border=1>
<tr><td>
text
</td><td>
The text to be converted can be supplied as <code>char</code>, <code>string</code>, or
<code>cellstr</code>. Which characters are allowed is determined by the font. However, all fonts
contain the printable and blank characters below 127. Any non-standard newline characters are
ignored (i.e. LF/CR/CRLF are parsed as newline). Non-scalar inputs (or non-row vector inputs in
the case of <code>char</code>) are allowed, but might not return the desired result.
</td></tr>
<tr><td>
font
</td><td>
Font name as char array. Which fonts are available is dictated by the internal
<code>text2im_load_database</code> function. See the table below for more details and the
options.
</td></tr>
</table>
</p><h2 id="5">Fonts</h2><p>
<table border=1>
<tr><td>
Font ID
</td><td>
Description and license
</td><td>
Character size
</td></tr>
<tr><td>
<code>'cmu_typewriter_text'</code>
</td><td>
This typeface contains 365 characters. This is a public domain typeface. <a
href="http://web.archive.org/web/20200418101117im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_CMU_Typewriter_Text.png">[link]</a>
</td><td>
<code>size=90x55</code>
</td></tr>
<tr><td>
<code>'cmu_concrete'</code>
</td><td>
This typeface contains 364 characters. This is a public domain typeface. <a
href="http://web.archive.org/web/20200418093550im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_CMU_Concrete.png">[link]</a>
</td><td>
<code>size=90x75</code>
</td></tr>
<tr><td>
<code>'ascii'</code>
</td><td>
This typeface contains only 94 characters (all printable <code>char</code>s below 127). This
typeface was previously published in the <code>text2im()</code> (published on the <a
href="https://www.mathworks.com/matlabcentral/fileexchange/19896">FileExchange</a>
by Tobias Kiessling). <a
href="http://web.archive.org/web/20200418093459im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_ASCII.png">[link]</a>
</td><td>
<code>size=20x18</code>
</td></tr>
<tr><td>
<code>'droid_sans_mono'</code>
</td><td>
This typeface contains 411 characters and has an Apache License (Version 2.0). <a
href="http://web.archive.org/web/20200418093741im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_Droid_Sans_Mono.png">[link]</a>
</td><td>
<code>size=95x51</code>
</td></tr>
<tr><td>
<code>'ibm_plex_mono'</code>
</td><td>
This typeface contains 376 characters and has an SIL Open Font License. <a
href="http://web.archive.org/web/20200418093815im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_IBM_Plex_Mono.png">[link]</a>
</td><td>
<code>size=95x51</code>
</td></tr>
<tr><td>
<code>'liberation_mono'</code>
</td><td>
This typeface contains 415 characters and has a GNU General Public License. <a
href="http://web.archive.org/web/20200418093840im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_Liberation_Mono.png">[link]</a>
</td><td>
<code>size=95x51</code>
</td></tr>
<tr><td>
<code>'monoid'</code>
</td><td>
This typeface contains 398 characters and has an MIT License. <a
href="http://web.archive.org/web/20200418093903im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_Monoid.png">[link]</a>
</td><td>
<code>size=95x51</code>
</td></tr>
</table>
</p><h2 id="6">Compatibility, version info, and licence</h2><p>
Compatibility considerations:
<ul>
   <li>Multiline inputs may have more trailing blank elements than intended. This is especially
      true for characters encoded with multiple elements (>127 for Octave and >65535 for
      Matlab).</li>
</ul>
</p><p>
<table>
<tr>
<td> Test suite result </td>
<td style="border:2px solid black;"> Windows XP/7/10 </td>
<td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
<td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2021a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2020b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2020a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2018a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2015a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2013b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2012b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2011a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2010b </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2010a </td>
<td> <it>W7 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2007b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab 7.1 (R14SP3) </td>
<td> <it>XP : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab 6.5 (R13) </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 6.2.0 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 5.2.0 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 4.4.1 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
</tr>
</table>
</p><pre>Version: 1.1.0
Date:    2021-05-19
Author:  H.J. Wisselink
Licence: CC by-nc-sa 4.0 ( https://creativecommons.org/licenses/by-nc-sa/4.0 )
Email = 'h_j_wisselink*alumnus_utwente_nl';
Real_email = regexprep(Email,{'*','_'},{'@','.'})</pre><h2 id="7">Test suite</h2><p>This tester is included so you can test if your own modifications would introduce any bugs. These tests form the basis for the compatibility table above.</p><p>Note that some of the functions in this tester might be different from the functions included in the actual function. Usually this is done to allow triggering of certain errors.</p><p>To save space, the tester function below was minified. The full tester function (including all comments) can be found <a href="https://web.archive.org/web/20210519084028/https://cdn-123.anonfiles.com/v8c5V3w8u5/3a0eb29e-1621414215/aaa___text2im___test.m">here</a>.</p><pre class="codeinput"><span class="comment">% Compare the output to pre-computed hashes to test exact equivalence</span>
<span class="comment">%</span>
<span class="comment">% Pass:    passes all tests</span>
<span class="comment">% Partial: [no partial passing condition]</span>
<span class="comment">% Fail:    fails any test</span>
<span class="comment">%</span>
<span class="keyword">function</span> v000=aaa___text2im___test(varargin),v000=<span class="string">'pass'</span>;<span class="keyword">if</span> nargin==0,v001=false;<span class="keyword">else</span>,v001=true;
<span class="keyword">end</span>,<span class="keyword">if</span> v001,v002=<span class="string">'No'</span>;<span class="keyword">else</span>,v002 = questdlg(<span class="string">'Test GUI?'</span>,<span class="string">''</span>,<span class="string">'Yes'</span>,<span class="string">'No'</span>,<span class="string">'Yes'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> strcmp(v002,<span class="keyword">...</span>
<span class="string">'Yes'</span>),v003=true;v004=text2im_load_database(<span class="string">'ascii'</span>,v003,<span class="string">'trigger GUI'</span>);<span class="keyword">else</span>,v003=true;v004=<span class="keyword">...</span>
text2im_load_database(<span class="string">'ascii'</span>,v003);<span class="keyword">end</span>,v005=<span class="string">'The quick brown fox jumped over the lazy dog.'</span>;
v006={ <span class="string">'cmu_typewriter_text'</span>,<span class="string">'F359E6752670A03B4B80BF9E2FD2FBD9'</span>;<span class="string">'cmu_concrete'</span>,<span class="keyword">...</span>
<span class="string">'E93A0D0F023D32DBF3D7A2555D78B825'</span>;<span class="string">'ascii'</span>,<span class="string">'A9D394C668F29F293477DBBDCC0E7877'</span>;<span class="string">'droid_sans_mono'</span>,<span class="keyword">...</span>
<span class="string">'262172A9734A48009EAB2E7ACB8D20BD'</span>;<span class="string">'ibm_plex_mono'</span>,<span class="string">'353FA726802F4E99A76BB8FCFC50ECCE'</span>;
<span class="string">'liberation_mono'</span>,<span class="string">'2AE74A75F3F8A93B7021E44F9B96C50F'</span>;<span class="string">'monoid'</span>,<span class="keyword">...</span>
<span class="string">'F96E8394C5AFB2412A123D3D05E7DA0E'</span>};v007=size(v006,1);<span class="keyword">if</span> ~v001,figure(1),clf(1),subplot(v007+1,<span class="keyword">...</span>
1,1),imshow(text2im(v005)),title(<span class="string">'default font'</span>),<span class="keyword">end</span>,<span class="keyword">for</span> v008=1:v007,v009=text2im(v005,<span class="keyword">...</span>
v006{v008,1});v010=ComputeNonCryptHash(v009,128,<span class="string">'-v2'</span>);<span class="keyword">if</span> ~strcmp(v010,v006{v008,2}),<span class="keyword">...</span>
error(<span class="string">'hash of generated image didn''t match hash in library'</span>),<span class="keyword">end</span>,<span class="keyword">if</span> ~v001,subplot(v007+1,1,<span class="keyword">...</span>
v008+1),imshow(v009),title(strrep(v006{v008,1},<span class="string">'_'</span>,<span class="string">'\_'</span>)),<span class="keyword">end</span>,<span class="keyword">end</span>,v011=[9 32 160 5760 8192:8202 <span class="keyword">...</span>
8239 8287];v012=[10 11 12 13 133 8232 8233];v013=[173 8203 8204 8205 8288];v014=<span class="keyword">...</span>
unicode_to_char([v011 v012 v013]);<span class="keyword">try</span> v009=text2im(v014);v010=ComputeNonCryptHash(v009,128,<span class="keyword">...</span>
<span class="string">'-v2'</span>);<span class="keyword">if</span> ~strcmp(v010,<span class="string">'5A61900CFEC38271667B13E7C768D652'</span>),error(<span class="string">'hash comparison failed'</span>);<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">catch</span>,<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(<span class="string">'UTF-8 handling failed'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">try</span> v009=<span class="keyword">...</span>
text2im({<span class="string">'This will be two lines of the default font.'</span>,v005});v010=ComputeNonCryptHash(v009,128,<span class="keyword">...</span>
<span class="string">'-v2'</span>);<span class="keyword">if</span> ~strcmp(v010,<span class="string">'0EAAFD74F57FE4735F318D4B9A079656'</span>),error(<span class="string">'hash comparison failed'</span>);<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">catch</span>,<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(<span class="string">'multiline failed'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
disp(<span class="string">'test completed'</span>),<span class="keyword">if</span> nargout==0,clear,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=AddMissing(v001,v000),v002=fieldnames(v001);v003=fieldnames(v000);<span class="keyword">for</span> v004=<span class="keyword">...</span>
find(~ismember(v002,v003)).',v005=v002{v004};v000.(v005)=v001.(v005);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs(varargin),v000=true;v002=struct;
<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003=struct;v003.HashLength=256;v003.Version=2;
v003.VersionFlag=<span class="string">'-v2'</span>;v003.SkipInputParse=false;v003.isSaltCall=false;v004=struct;
v003.print_to_con=true;v004.print_to_con=v003.print_to_con;v003.print_to_fid=[];
v004.print_to_fid=v003.print_to_fid;v003.print_to_obj=[];v004.print_to_obj=v003.print_to_obj;
v003.print_to_fcn=[];v004.print_to_fcn=v003.print_to_fcn;v003.print_2__default_options=v004;
v003.print_2__options=validate_print_to__options(v004);<span class="keyword">end</span>,<span class="keyword">if</span> nargin==0,v001=<span class="keyword">...</span>
ComputeNonCryptHash_DefaultsByVersion(v003);<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">if</span> nargin==1,<span class="keyword">switch</span> class(varargin{1}),<span class="keyword">...</span>
<span class="keyword">case</span> {<span class="string">'char'</span>,<span class="string">'string'</span>},v001=AddMissing(v003,struct(<span class="string">'VersionFlag'</span>,char(varargin{1})));<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'struct'</span>,v001=AddMissing(v003,varargin{1});<span class="keyword">otherwise</span>,v001=AddMissing(v003,struct(<span class="string">'HashLength'</span>,<span class="keyword">...</span>
varargin{1}));<span class="keyword">end</span>,[v001,v002,v000]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);<span class="keyword">if</span> <span class="keyword">...</span>
v000,v001=ComputeNonCryptHash_DefaultsByVersion(v001);<span class="keyword">end</span>,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">try</span> [v001,v002,v005]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__UnwindToStruct( struct,v002,~v000,varargin{:});v000=~v005;
<span class="keyword">catch</span>,v002.identifier=<span class="string">'HJW:ComputeNonCryptHash:InputFail'</span>;v002.message=<span class="keyword">...</span>
<span class="string">'Input parsing failed. Maybe a parameter has been entered twice.'</span>;v000=false;<span class="keyword">end</span>,<span class="keyword">if</span> ~v000,<span class="keyword">...</span>
<span class="keyword">return</span>,<span class="keyword">else</span> ,v001=AddMissing(v003,v001);<span class="keyword">end</span>,[v001,v002,v000]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);<span class="keyword">if</span> v000,v001=<span class="keyword">...</span>
ComputeNonCryptHash_DefaultsByVersion(v001);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v000),v002=true;v001=<span class="keyword">...</span>
struct;<span class="keyword">try</span> v003=str2double(v000.VersionFlag(3:end));<span class="keyword">if</span> isnan(v003) || round(v003)~=v003 || <span class="keyword">...</span>
v003&gt;2,error(<span class="string">'trigger'</span>);<span class="keyword">end</span>,v000.Version=v003;<span class="keyword">catch</span>,v001.identifier=<span class="keyword">...</span>
<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>;v001.message=<span class="keyword">...</span>
<span class="string">'Version input incorrect. Must be ''-v1'', ''-v2''.'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,v004=v000.HashLength;
<span class="keyword">if</span> numel(v004)~=1 || ~isnumeric(v004) || mod(v004,16)~=0 || v004&lt;16,v001.identifier=<span class="keyword">...</span>
<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>;v001.message=<span class="keyword">...</span>
<span class="string">'Second input (hash length) must be a multiple of 16.'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v005=<span class="keyword">...</span>
fieldnames(v000.print_2__default_options),<span class="keyword">if</span> ~isequal(v000.(v005{1}),<span class="keyword">...</span>
v000.print_2__default_options.(v005{1})),[v006,v001]=validate_print_to__options(v000);<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v006),v001.identifier=<span class="string">'HJW:ComputeNonCryptHash:PrintToIncorrect'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v000.print_2__options=v006;<span class="keyword">break</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,<span class="keyword">...</span>
varargin),<span class="keyword">if</span> v002 || numel(varargin)==0,<span class="keyword">return</span>,<span class="keyword">end</span>,v003=varargin{1};<span class="keyword">if</span> isa(v003,<span class="string">'struct'</span>),v004=<span class="keyword">...</span>
fieldnames(v000);v005=fieldnames(v003);v006=unique([v004;v005]);<span class="keyword">if</span> numel(v004)+numel(v005) ~= <span class="keyword">...</span>
numel(v006),v002=true;<span class="keyword">return</span>,<span class="keyword">end</span>,v000=AddMissing(v000,v003);varargin(1)=[];<span class="keyword">elseif</span> isa(v003,<span class="keyword">...</span>
<span class="string">'char'</span>) || isa(v003,<span class="string">'string'</span>),<span class="keyword">try</span> <span class="keyword">if</span> isa(v003,<span class="string">'string'</span>),v003=char(v003);<span class="keyword">end</span>,<span class="keyword">if</span> strcmpi(<span class="string">'-v'</span>,<span class="keyword">...</span>
v003(1:2)),<span class="keyword">if</span> isfield(v000,<span class="string">'VersionFlag'</span>),error(<span class="string">'trigger'</span>),<span class="keyword">end</span>,v000.VersionFlag=v003;
varargin(1)=[];<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v000,v003),error(<span class="string">'trigger'</span>),<span class="keyword">end</span>,v000.(v003)=varargin{2};
varargin(1:2)=[];<span class="keyword">end</span>,<span class="keyword">catch</span>,v002=true;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v000,<span class="string">'HashLength'</span>),v002=true;
<span class="keyword">return</span>,<span class="keyword">end</span>,v000.HashLength=v003;varargin(1)=[];<span class="keyword">end</span>,[v000,v001,v002]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,varargin{:});<span class="keyword">end</span>
<span class="keyword">function</span> v004=get_MatFileFlag,<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v001=exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="keyword">...</span>
<span class="string">'builtin'</span>);v002=version;v003=min([numel(v002) strfind(v002,<span class="string">'.'</span>)]);v002=<span class="keyword">...</span>
str2double(v002(1:(v003-1)));<span class="keyword">if</span> v001 || v002&lt;7,v000=<span class="string">'-mat'</span>;<span class="keyword">else</span>,v000=<span class="string">'-v6'</span>;<span class="keyword">end</span>,<span class="keyword">end</span>,v004=v000;<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=GetWritableFolder(varargin),[v002,v003,v004]=<span class="keyword">...</span>
GetWritableFolder_parse_inputs(varargin{:});<span class="keyword">if</span> ~v002,rethrow(v004),<span class="keyword">else</span>,[v005,v006,v007]=<span class="keyword">...</span>
deal(v003.ForceStatus,v003.ErrorOnNotFound,v003.root_folder_list);<span class="keyword">end</span>,v007{end}=pwd;<span class="keyword">if</span> v005,<span class="keyword">...</span>
v001=v005;v000=fullfile(v007{v001},<span class="string">'PersistentFolder'</span>);<span class="keyword">try</span> <span class="keyword">if</span> ~exist(v000,<span class="string">'dir'</span>),mkdir(v000);
<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">return</span>,<span class="keyword">end</span>,v001=1;v000=v007{v001};<span class="keyword">try</span> <span class="keyword">if</span> ~exist(v000,<span class="string">'dir'</span>),mkdir(v000);<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">if</span> ~TestFolderWritePermission(v000),v001=2;v000=v007{v001};<span class="keyword">try</span> <span class="keyword">if</span> ~exist(v000,<span class="string">'dir'</span>),<span class="keyword">...</span>
mkdir(v000);<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">if</span> ~TestFolderWritePermission(v000),v001=3;v000=v007{v001};<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v000=fullfile(v000,<span class="string">'PersistentFolder'</span>);<span class="keyword">try</span> <span class="keyword">if</span> ~exist(v000,<span class="string">'dir'</span>),mkdir(v000);<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~TestFolderWritePermission(v000),<span class="keyword">if</span> v006,error(<span class="string">'HJW:GetWritableFolder:NoWritableFolder'</span>,<span class="keyword">...</span>
<span class="string">'This function was unable to find a folder with write permissions.'</span>),<span class="keyword">else</span>,v001=0;v000=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=get_trace(v002,v001),<span class="keyword">if</span> nargin==0,v002=1;<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;2, v001=dbstack;<span class="keyword">end</span>,<span class="keyword">...</span>
v001(1:v002)=[];<span class="keyword">if</span> ~isfield(v001,<span class="string">'file'</span>),<span class="keyword">for</span> v003=1:numel(v001),v004=v001(v003).name;<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v004(end),<span class="string">')'</span>),v005=strfind(v004,<span class="string">'('</span>);v006=v004( (v005(end)+1):(end-1) );v007=<span class="keyword">...</span>
v004(1:(v005(end)-2));<span class="keyword">else</span>,v007=v004;[v008,v006]=fileparts(v004);<span class="keyword">end</span>,[v008,v001(v003).file]=<span class="keyword">...</span>
fileparts(v007);v001(v003).name=v006;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">persistent</span> v009,<span class="keyword">if</span> isempty(v009),v009=<span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>,<span class="string">'builtin'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> v009,<span class="keyword">for</span> v003=1:numel(v001),[v008,v001(v003).file]=<span class="keyword">...</span>
fileparts(v001(v003).file);<span class="keyword">end</span>,<span class="keyword">end</span>,v010=v001;v011=<span class="string">'&gt;'</span>;v000=cell(1,numel(v010)-1);<span class="keyword">for</span> v003=<span class="keyword">...</span>
1:numel(v010),[v012,v010(v003).file,v013]=fileparts(v010(v003).file);<span class="keyword">if</span> v003==numel(v010),<span class="keyword">...</span>
v010(v003).file=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> strcmp(v010(v003).file,v010(v003).name),v010(v003).file=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isempty(v010(v003).file),v010(v003).file=[v010(v003).file <span class="string">'&gt;'</span>];<span class="keyword">end</span>,v000{v003}=<span class="keyword">...</span>
sprintf(<span class="string">'%c In %s%s (line %d)\n'</span>,v011,v010(v003).file,v010(v003).name,v010(v003).line);v011=<span class="string">' '</span>;
<span class="keyword">end</span>,v000=horzcat(v000{:});<span class="keyword">end</span>
<span class="keyword">function</span> error_(v001,varargin),<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v000=func2str(@error_);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v001),v001=struct;<span class="keyword">end</span>,v001=parse_warning_error_redirect_options(v001);[v002,v003,v004,<span class="keyword">...</span>
v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct(<span class="string">'identifier'</span>,v002,<span class="string">'message'</span>,<span class="keyword">...</span>
v003,<span class="string">'stack'</span>,v004);<span class="keyword">if</span> v001.boolean.obj,v007=v003;<span class="keyword">while</span> v007(end)==10,v007(end)=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
any(v007==10),v007=char2cellstr([<span class="string">'Error: '</span> v007]);<span class="keyword">else</span>,v007=[<span class="string">'Error: '</span> v007];<span class="keyword">end</span>,<span class="keyword">for</span> v008=<span class="keyword">...</span>
v001.obj(:).',<span class="keyword">try</span> set(v008,<span class="string">'String'</span>,v007);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid,<span class="keyword">for</span> v009=<span class="keyword">...</span>
v001.fid(:).',<span class="keyword">try</span> fprintf(v009,<span class="string">'Error: %s\n%s'</span>,v003,v005);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fcn,<span class="keyword">...</span>
<span class="keyword">if</span> ismember(v000,{v004.name}),error(<span class="string">'prevent recursion'</span>),<span class="keyword">end</span>,<span class="keyword">for</span> v010=v001.fcn(:).',<span class="keyword">if</span> <span class="keyword">...</span>
isfield(v010,<span class="string">'data'</span>),<span class="keyword">try</span> feval(v010.h,<span class="string">'error'</span>,v006,v010.data);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">try</span> feval(v010.h,<span class="keyword">...</span>
<span class="string">'error'</span>,v006);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,rethrow(v006),<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=GetWritableFolder_parse_inputs(varargin),v000=false;v001=struct;v002=<span class="keyword">...</span>
struct(<span class="string">'identifier'</span>,<span class="string">''</span>,<span class="string">'message'</span>,<span class="string">''</span>);<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003.ForceStatus=false;
v003.ErrorOnNotFound=false;v003.root_folder_list={ GetPseudoAddonpath;fullfile(tempdir,<span class="keyword">...</span>
<span class="string">'MATLAB'</span>);<span class="string">''</span>};<span class="keyword">end</span>,<span class="keyword">if</span> nargin==2,v001=v003;v000=true;<span class="keyword">return</span>,<span class="keyword">end</span>,v004= nargin ==1 &amp;&amp; <span class="keyword">...</span>
isa(varargin{1},<span class="string">'struct'</span>);v005=mod(nargin,2)==0 &amp;&amp; all( cellfun(<span class="string">'isclass'</span>,varargin(1:2:end),<span class="keyword">...</span>
<span class="string">'char'</span> ) | cellfun(<span class="string">'isclass'</span>,varargin(1:2:end),<span class="string">'string'</span>) );<span class="keyword">if</span> ~( v004 || v005 ),v002.message=<span class="keyword">...</span>
[<span class="string">'The input is expected to be either a struct, '</span>,char(10),<span class="string">'or consist of Name,Value pairs.'</span>];
v002.identifier=<span class="string">'HJW:GetWritableFolder:incorrect_input_options'</span>;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v005,<span class="keyword">for</span> v006=<span class="keyword">...</span>
1:2:numel(varargin),<span class="keyword">try</span> v001.(varargin{v006})=varargin{v006+1};<span class="keyword">catch</span>,v002.message=<span class="keyword">...</span>
<span class="string">'Parsing of Name,Value pairs failed.'</span>;v002.identifier=<span class="keyword">...</span>
<span class="string">'HJW:GetWritableFolder:incorrect_input_NameValue'</span>;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,v001=varargin{1};<span class="keyword">end</span>,v007=<span class="keyword">...</span>
fieldnames(v001);<span class="keyword">for</span> v008=1:numel(v007),v009=v007{v008};v010=v001.(v009);v002.identifier=<span class="keyword">...</span>
[<span class="string">'HJW:GetWritableFolder:incorrect_input_opt_'</span> lower(v009)];<span class="keyword">switch</span> v009,<span class="keyword">case</span> <span class="string">'ForceStatus'</span>,<span class="keyword">try</span> <span class="keyword">...</span>
<span class="keyword">if</span> ~isa(v003.root_folder_list{v010},<span class="string">'char'</span>),<span class="keyword">...</span>
error(<span class="string">'the indexing must have failed, trigger error'</span>),<span class="keyword">end</span>,<span class="keyword">catch</span>,v002.message=<span class="keyword">...</span>
sprintf(<span class="string">'Invalid input: expected a scalar integer between 1 and %d.'</span>,<span class="keyword">...</span>
numel(v003.root_folder_list));<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">case</span> <span class="string">'ErrorOnNotFound'</span>,[v011,v001.ErrorOnNotFound]=<span class="keyword">...</span>
test_if_scalar_logical(v010);<span class="keyword">if</span> ~v011,v002.message=<span class="keyword">...</span>
<span class="string">'ErrorOnNotFound should be either true or false.'</span>;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">otherwise</span>,v002.message=<span class="keyword">...</span>
sprintf(<span class="string">'Name,Value pair not recognized: %s.'</span>,v009);v002.identifier=<span class="keyword">...</span>
<span class="string">'HJW:GetWritableFolder:incorrect_input_NameValue'</span>;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v007=fieldnames(v003);<span class="keyword">for</span> v008=<span class="keyword">...</span>
1:numel(v007),<span class="keyword">if</span> ~isfield(v001,v007(v008)),v001.(v007{v008})=v003.(v007{v008});<span class="keyword">end</span>,<span class="keyword">end</span>,v000=<span class="keyword">...</span>
true;v002=[];<span class="keyword">end</span>
<span class="keyword">function</span> v002=GetPseudoAddonpath,<span class="keyword">if</span> ispc,[v000,v001]=system(<span class="string">'echo %APPDATA%'</span>);v001(v001&lt;14)=<span class="string">''</span>;
v002=fullfile(v001,<span class="string">'MathWorks'</span>,<span class="string">'MATLAB Add-Ons'</span>);<span class="keyword">else</span>,[v000,v003]=system(<span class="string">'echo $HOME'</span>);
v003(v003&lt;14)=<span class="string">''</span>;v002=fullfile(v003,<span class="string">'Documents'</span>,<span class="string">'MATLAB'</span>,<span class="string">'Add-Ons'</span>);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ifversion(v001,v002,v003,v004,v005),<span class="keyword">persistent</span> v006 v007 v008,<span class="keyword">if</span> isempty(v006),<span class="keyword">...</span>
v008=exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>);v006=version;v009=strfind(v006,<span class="string">'.'</span>);<span class="keyword">if</span> numel(v009)~=1,<span class="keyword">...</span>
v006(v009(2):end)=<span class="string">''</span>;v009=v009(1);<span class="keyword">end</span>,v006=[str2double(v006(1:(v009-1))) <span class="keyword">...</span>
str2double(v006((v009+1):end))];v006=v006(1)+v006(2)/100;v006=round(100*v006);v007={ <span class="string">'R13'</span> 605;
<span class="string">'R13SP1'</span> 605;<span class="string">'R13SP2'</span> 605;<span class="string">'R14'</span> 700;<span class="string">'R14SP1'</span> 700;<span class="string">'R14SP2'</span> 700;<span class="string">'R14SP3'</span> 701;<span class="string">'R2006a'</span> 702;
<span class="string">'R2006b'</span> 703;<span class="string">'R2007a'</span> 704;<span class="string">'R2007b'</span> 705;<span class="string">'R2008a'</span> 706;<span class="string">'R2008b'</span> 707;<span class="string">'R2009a'</span> 708;<span class="string">'R2009b'</span> 709;
<span class="string">'R2010a'</span> 710;<span class="string">'R2010b'</span> 711;<span class="string">'R2011a'</span> 712;<span class="string">'R2011b'</span> 713;<span class="string">'R2012a'</span> 714;<span class="string">'R2012b'</span> 800;<span class="string">'R2013a'</span> 801;
<span class="string">'R2013b'</span> 802;<span class="string">'R2014a'</span> 803;<span class="string">'R2014b'</span> 804;<span class="string">'R2015a'</span> 805;<span class="string">'R2015b'</span> 806;<span class="string">'R2016a'</span> 900;<span class="string">'R2016b'</span> 901;
<span class="string">'R2017a'</span> 902;<span class="string">'R2017b'</span> 903;<span class="string">'R2018a'</span> 904;<span class="string">'R2018b'</span> 905;<span class="string">'R2019a'</span> 906;<span class="string">'R2019b'</span> 907;<span class="string">'R2020a'</span> 908;
<span class="string">'R2020b'</span> 909;<span class="string">'R2021a'</span> 910};<span class="keyword">end</span>,<span class="keyword">if</span> v008,<span class="keyword">if</span> nargin==2,warning(<span class="string">'HJW:ifversion:NoOctaveTest'</span>,<span class="keyword">...</span>
[<span class="string">'No version test for Octave was provided.'</span>,char(10),<span class="keyword">...</span>
<span class="string">'This function might return an unexpected outcome.'</span>]),<span class="keyword">if</span> isnumeric(v002),v010=<span class="keyword">...</span>
0.1*v002+0.9*fix(v002);v010=round(100*v010);<span class="keyword">else</span>,v011=ismember(v007(:,1),v002);<span class="keyword">if</span> sum(v011)~=1,<span class="keyword">...</span>
warning(<span class="string">'HJW:ifversion:NotInDict'</span>,<span class="string">'The requested version is not in the hard-coded list.'</span>),v000=<span class="keyword">...</span>
NaN;<span class="keyword">return</span>,<span class="keyword">else</span>,v010=v007{v011,2};<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">elseif</span> nargin==4,[v001,v010]=deal(v003,v004);v010=<span class="keyword">...</span>
0.1*v010+0.9*fix(v010);v010=round(100*v010);<span class="keyword">else</span>,[v001,v010]=deal(v004,v005);v010=<span class="keyword">...</span>
0.1*v010+0.9*fix(v010);v010=round(100*v010);<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> isnumeric(v002),v010=<span class="keyword">...</span>
0.1*v002+0.9*fix(v002);v010=round(100*v010);<span class="keyword">else</span>,v011=ismember(v007(:,1),v002);<span class="keyword">if</span> sum(v011)~=1,<span class="keyword">...</span>
warning(<span class="string">'HJW:ifversion:NotInDict'</span>,<span class="string">'The requested version is not in the hard-coded list.'</span>),v000=<span class="keyword">...</span>
NaN;<span class="keyword">return</span>,<span class="keyword">else</span>,v010=v007{v011,2};<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">switch</span> v001,<span class="keyword">case</span> <span class="string">'=='</span>, v000= v006 == v010;<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'&lt;'</span> , v000= v006 &lt; v010;<span class="keyword">case</span> <span class="string">'&lt;='</span>, v000= v006 &lt;= v010;<span class="keyword">case</span> <span class="string">'&gt;'</span> , v000= v006 &gt; v010;<span class="keyword">case</span> <span class="string">'&gt;='</span>, <span class="keyword">...</span>
v000= v006 &gt;= v010;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=bsxfun_plus(v001,v002),<span class="keyword">try</span> v000=v001+v002;<span class="keyword">catch</span>,<span class="keyword">try</span> v000=bsxfun(@plus,v001,v002);
<span class="keyword">catch</span>,v003=size(v001); v004=size(v002);v001=repmat(v001,max(1,v004./v003)); v002=repmat(v002,<span class="keyword">...</span>
max(1,v003./v004));v000=v001+v002;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002,v003]=parse_warning_error_redirect_inputs(varargin),<span class="keyword">if</span> nargin==1,<span class="keyword">if</span> <span class="keyword">...</span>
isa(varargin{1},<span class="string">'struct'</span>) || isa(varargin{1},<span class="string">'MException'</span>),v004=varargin{1};<span class="keyword">try</span> v002=v004.stack;
v003=get_trace(0,v002);<span class="keyword">catch</span>,[v003,v002]=get_trace(3);<span class="keyword">end</span>,v000=v004.identifier;v001=<span class="keyword">...</span>
v004.message;v005=<span class="keyword">...</span>
<span class="string">'Error using &lt;a href="matlab:matlab.internal.language.introspective.errorDocCallback('</span>;<span class="keyword">if</span> <span class="keyword">...</span>
isa(v004,<span class="string">'struct'</span>) &amp;&amp; numel(v001)&gt;numel(v005) &amp;&amp; strcmp(v005,v001(1:numel(v005))),<span class="keyword">...</span>
v001(1:find(v001==10,1))=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">else</span>,[v003,v002]=get_trace(3);[v000,v001]=deal(<span class="string">''</span>,varargin{1});
<span class="keyword">end</span>,<span class="keyword">else</span>,[v003,v002]=get_trace(3);<span class="keyword">if</span> ~isempty(strfind(varargin{1},<span class="string">'%'</span>)),v000=<span class="string">''</span>;v006=<span class="keyword">...</span>
varargin(2:end);v001=sprintf(varargin{1},v006{:});<span class="keyword">else</span>,v000=varargin{1};v001=varargin{2};<span class="keyword">if</span> <span class="keyword">...</span>
nargin&gt;3,v006=varargin(3:end);v001=sprintf(v001,v006{:});<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__cell(v000,v001),v002=size(v000).';v000=v000(:);<span class="keyword">for</span> v003=<span class="keyword">...</span>
1:numel(v000),<span class="keyword">if</span> numel(v000{v003})==0,v004=double(class(v000{v003})');v000{v003}=uint16([0;v004;
size(v000{v003})']);<span class="keyword">continue</span>,<span class="keyword">end</span>,<span class="keyword">switch</span> class(v000{v003}),<span class="keyword">case</span> {<span class="string">'double'</span>,<span class="string">'single'</span>},v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__floats(v000{v003});<span class="keyword">case</span> <span class="string">'logical'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__logical(v000{v003});<span class="keyword">case</span> {<span class="string">'uint8'</span>,<span class="string">'uint16'</span>,<span class="string">'uint32'</span>,<span class="string">'uint64'</span>,<span class="string">'int8'</span>,<span class="keyword">...</span>
<span class="string">'int16'</span>,<span class="string">'int32'</span>,<span class="string">'int64'</span>},v000{v003}=cast_to_uint16_vector__integer(v000{v003},v001);<span class="keyword">case</span> <span class="string">'char'</span>,<span class="keyword">...</span>
v000{v003}=cast_to_uint16_vector__char(v000{v003},v001);<span class="keyword">case</span> <span class="string">'string'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__string(v000{v003},v001);<span class="keyword">case</span> <span class="string">'cell'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__cell(v000{v003},v001);<span class="keyword">case</span> <span class="string">'struct'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__struct(v000{v003},v001);<span class="keyword">case</span> {<span class="string">'gpuArray'</span>,<span class="string">'tall'</span>},v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__cell({gather(v000{v003})},v001);<span class="keyword">otherwise</span>,error_(v001.print_to,<span class="keyword">...</span>
<span class="string">'HJW:cast_to_uint16_vector:nosupport'</span>,<span class="string">'Unsupported data type in nested variable'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,v000=<span class="keyword">...</span>
cell2mat(v000);v000=[v000;uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__floats(v000),v001=size(v000).';v002=class(v000);[v003,<span class="keyword">...</span>
v004]=typecast_double_uint64(double(v000));v005=mod(v003,2^16);v003=v003-v005;v003=v003/2^16;
v004=v004.';v006 =mod(v003,2^16);v003=v003-v006; v003=v003/2^16;v006=v006.';v007 =mod(v003,<span class="keyword">...</span>
2^16);v003=v003-v007; v003=v003/2^16;v007=v007.';v008 =mod(v003,2^16); v008=v008.';v000=[v008;
v007;v006;v004];v000=uint16(v000(:));v000=[v000;uint16(v002.');uint16(mod(v001,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__logical(v000),v001=size(v000).';v000=v000(:);<span class="keyword">if</span> <span class="keyword">...</span>
mod(numel(v000),16),v000(16*ceil(numel(v000)/16))=0;<span class="keyword">end</span>,v002=uint16(2.^(15:-1:0))';v000=<span class="keyword">...</span>
uint16(reshape(v000,16,[]));<span class="keyword">try</span> v000=v000.*v002;<span class="keyword">catch</span>,v000=double(v000).*repmat(double(v002),[1 <span class="keyword">...</span>
size(v000,2)]);v000=uint16(v000);<span class="keyword">end</span>,v000=uint16(sum(v000,1)).';v000=[v000;uint16(mod(v001,<span class="keyword">...</span>
2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__struct(v000,v001),v002=size(v000).';v000=v000(:);v003=<span class="keyword">...</span>
fieldnames(v000);v004=cell(2,numel(v003));<span class="keyword">for</span> v005=1:numel(v003),v004{1,v005}=v003{v005};v004{2,<span class="keyword">...</span>
v005}={v000.(v003{v005})};<span class="keyword">end</span>,v000=cast_to_uint16_vector__cell(v004,v001);v000=[v000;
uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=char2cellstr(v001,v002),v003=isa(v001,<span class="string">'char'</span>);v001=int32(v001);<span class="keyword">if</span> nargin&lt;2,<span class="keyword">if</span> <span class="keyword">...</span>
any(v001==13),v001=PatternReplace(v001,int32([13 10]),int32(-10));v001(v001==13)=-10;<span class="keyword">end</span>,<span class="keyword">...</span>
v001(v001==10)=-10;<span class="keyword">else</span>,<span class="keyword">for</span> v004=1:numel(v002),v001=PatternReplace(v001,int32(v002{v004}),<span class="keyword">...</span>
int32(-10));<span class="keyword">end</span>,<span class="keyword">end</span>,v005=[0 find(v001==-10) numel(v001)+1];v000=cell(numel(v005)-1,1);<span class="keyword">for</span> v004=<span class="keyword">...</span>
1:numel(v000),v006=(v005(v004 )+1);v007=(v005(v004+1)-1);v000{v004}=v001(v006:v007);<span class="keyword">end</span>,<span class="keyword">if</span> v003,<span class="keyword">...</span>
<span class="keyword">for</span> v004=1:numel(v000),v000{v004}= char(v000{v004});<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">for</span> v004=1:numel(v000),v000{v004}=<span class="keyword">...</span>
uint32(v000{v004});<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash(v001,varargin),<span class="keyword">if</span> nargin&lt;1,<span class="keyword">...</span>
error(<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>,<span class="string">'At least 1 input required.'</span>),<span class="keyword">end</span>,<span class="keyword">if</span> nargin==2 <span class="keyword">...</span>
&amp;&amp; isa(varargin{1},<span class="string">'struct'</span>) &amp;&amp; varargin{1}.SkipInputParse,v002=varargin{1};<span class="keyword">else</span>,[v003,v002,<span class="keyword">...</span>
v004]=ComputeNonCryptHash_parse_inputs(varargin{:});<span class="keyword">if</span> ~v003,rethrow(v004),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v002.print_to=v002.print_2__options;v005=v002.HashLength;v006=v002.Version;<span class="keyword">try</span> v004=[];v001=<span class="keyword">...</span>
cast_to_uint16_vector(v001,v002);<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v004.identifier,<span class="string">'MATLAB:nomem'</span>),error_(v002.print_to,v004),<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v002,<span class="string">'debug'</span>) <span class="keyword">...</span>
&amp;&amp; v002.debug,v007=sprintf(<span class="string">'\n[original error: %s %s]'</span>,v004.identifier,v004.message);<span class="keyword">else</span>,v007=<span class="keyword">...</span>
<span class="string">''</span>;<span class="keyword">end</span>,error_(v002.print_to,<span class="string">'HJW:ComputeNonCryptHash:UnwindFailed'</span>,<span class="keyword">...</span>
[<span class="string">'The nested input contains an unsupported data type.'</span> v007]),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> mod(numel(v001),<span class="keyword">...</span>
v005/16),v008=uint16(1:v005/16).'; v008(1:mod(numel(v001),v005/16))=[];v001=[v001;v008];<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v006==1,v001=ComputeNonCryptHash_shuffle_uint16(v001);v001=<span class="keyword">...</span>
ComputeNonCryptHash_uint16_to_logical(v001);v001=xor(v001,reshape(v001,[],16).');<span class="keyword">else</span>,v001=<span class="keyword">...</span>
ComputeNonCryptHash_shuffle_uint16(v001);v001=ComputeNonCryptHash_uint16_to_logical(v001);v001=<span class="keyword">...</span>
circshift_by_col(v001);<span class="keyword">end</span>,v001=mod(sum(reshape(v001,v005,[]),2),2);v001=<span class="keyword">...</span>
ComputeNonCryptHash_logical_to_uint16(v001);<span class="keyword">if</span> v002.isSaltCall,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,v001=<span class="keyword">...</span>
ComputeNonCryptHash_add_salt(v001,v002);v000=ComputeNonCryptHash_dec2hex(v001);v000=<span class="keyword">...</span>
reshape(v000.',1,[]);<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector(v000,v001),<span class="keyword">if</span> isa(v000,<span class="string">'uint16'</span>),v002=<span class="string">'uint16'</span>;v003=<span class="keyword">...</span>
size(v000).';v000=reshape(v000,[],1);v000=[v000;uint16(v002.');uint16(mod(v003,2^16))];<span class="keyword">return</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,v000=cast_to_uint16_vector__cell({v000},v001);v000([end-1 end])=[];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__integer(v000,v001),v002=size(v000).';v000=v000(:);
<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003=ifversion(<span class="string">'&gt;='</span>,<span class="string">'R2010b'</span>,<span class="string">'Octave'</span>,<span class="string">'&gt;'</span>,0);<span class="keyword">end</span>,v004=<span class="keyword">...</span>
class(v000);v005=~v001.cast_int64_double &amp;&amp; v003 &amp;&amp; v004(end)==<span class="string">'4'</span>;<span class="keyword">if</span> ~v005,<span class="keyword">if</span> <span class="keyword">...</span>
any(abs(double(v000(:)))&gt;2^52),warning_(v001,<span class="string">'HJW:ComputeNonCryptHash:int64rounding'</span>,<span class="keyword">...</span>
[<span class="string">'int64 and uint64 will be rounded pre-R2010b, resulting in rounding.'</span>,char(10),<span class="keyword">...</span>
<span class="string">'This will result in a hash that is different from newer releases.'</span>]),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v005,<span class="keyword">if</span> <span class="keyword">...</span>
v004(1)~=<span class="string">'u'</span>,v006=v000&gt;0;v007=-int64(-inf);v008=uint64(v000+v007+1);v008(v006)=<span class="keyword">...</span>
uint64(v000(v006))+uint64(v007)+1;v000=v008;<span class="keyword">end</span>,<span class="keyword">elseif</span> v004(1)~=<span class="string">'u'</span>,v000=<span class="keyword">...</span>
double(v000)-double(eval([v004 <span class="string">'(-inf)'</span>]));<span class="keyword">else</span>,v000=double(v000);<span class="keyword">end</span>,<span class="keyword">switch</span> v004(end),<span class="keyword">case</span> <span class="string">'8'</span>,<span class="keyword">...</span>
<span class="keyword">if</span> mod(numel(v000),2),v000(end+1)=0;<span class="keyword">end</span>,v000=reshape(v000,[],2);v000=v000(:,1)*255+v000(:,2);
v000=uint16(v000);<span class="keyword">case</span> <span class="string">'6'</span>,v000=uint16(v000);<span class="keyword">case</span> <span class="string">'2'</span>,v009=floor(v000/2^16);v009=v009.';v010=<span class="keyword">...</span>
mod(v000,2^16); v010=v010.';v000=[v009;v010];v000=uint16(v000(:));<span class="keyword">case</span> <span class="string">'4'</span>,v011=v000;v012=<span class="keyword">...</span>
mod(v011,2^16);v011=v011-v012;v011=v011/2^16;v012=v012.';v013=mod(v011,2^16);v011=v011-v013;
v011=v011/2^16;v013=v013.';v010=mod(v011,2^16);v011=v011-v010;v011=v011/2^16;v010=v010.';v009=<span class="keyword">...</span>
mod(v011,2^16); v009=v009.';v000=[v009;v010;v013;v012];v000=uint16(v000(:));<span class="keyword">end</span>,v000=[v000;
uint16(v004.');uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__string(v000,v001),<span class="keyword">if</span> v001.string_to_cellstr,v000=<span class="keyword">...</span>
cellstr(v000);v000=cast_to_uint16_vector__cell(v000,v001);<span class="keyword">else</span>,v000=char(v000);v000=<span class="keyword">...</span>
cast_to_uint16_vector__char(v000,v001);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__char(v000,v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> v002 &amp;&amp; v001.re_encode_char,v003 = size(v000,1)==<span class="keyword">...</span>
numel(v000);<span class="keyword">if</span> v003,v000=v000.';<span class="keyword">end</span>,v000=cellstr(v000);<span class="keyword">for</span> v004=1:numel(v000),v000{v004}=<span class="keyword">...</span>
unicode_to_char(UTF8_to_unicode(v000{v004},v001.print_to),true);<span class="keyword">end</span>,v005=cellfun(<span class="string">'length'</span>,v000);
v006=max(v005);<span class="keyword">for</span> v004=find(v005&lt;v006),v000{v004}( (numel(v000{v004})+1) : v006)=uint16(<span class="string">' '</span>);
<span class="keyword">end</span>,v000=cell2mat(v000);<span class="keyword">if</span> v003,v000=v000.';<span class="keyword">end</span>,<span class="keyword">end</span>,v007=size(v000).';v000=v000(:);v000=<span class="keyword">...</span>
uint16(v000);v000=[v000;uint16(mod(v007,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=parse_warning_error_redirect_options(v000),<span class="keyword">if</span> ~isfield(v000,<span class="string">'boolean'</span>),<span class="keyword">...</span>
v000.boolean=struct;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'con'</span>) || isempty(v000.boolean.con),<span class="keyword">...</span>
v000.boolean.con=false;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'fid'</span>) || isempty(v000.boolean.fid),<span class="keyword">...</span>
v000.boolean.fid=isfield(v000,<span class="string">'fid'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'obj'</span>) || <span class="keyword">...</span>
isempty(v000.boolean.obj),v000.boolean.obj=isfield(v000,<span class="string">'obj'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="keyword">...</span>
<span class="string">'fcn'</span>) || isempty(v000.boolean.fcn),v000.boolean.fcn=isfield(v000,<span class="string">'fcn'</span>);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=PatternReplace(v001,v002,v003),v000=v001(:)';<span class="keyword">if</span> numel(v002)==0,v004=<span class="keyword">...</span>
false(size(v001));<span class="keyword">elseif</span> numel(v003)&gt;numel(v002),error(<span class="string">'not implemented (padding required)'</span>),<span class="keyword">...</span>
<span class="keyword">else</span>,v004=true(size(v001));<span class="keyword">for</span> v005=1:numel(v002),v006=find(v001==v002(v005));v006=v006-v005+1;
v006(v006&lt;1)=[];v007=false(size(v004));v007(v006)=true;v004= v004 &amp; v007;<span class="keyword">if</span> ~any(v004),<span class="keyword">break</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v006=find(v004);<span class="keyword">if</span> ~isempty(v006),<span class="keyword">for</span> v005=1:numel(v003),v000(v006+v005-1)=<span class="keyword">...</span>
v003(v005);<span class="keyword">end</span>,<span class="keyword">if</span> numel(v003)==0,v005=0;<span class="keyword">end</span>,<span class="keyword">if</span> numel(v002)&gt;v005,v006=v006(:);v008=<span class="keyword">...</span>
(v005+1):numel(v002);v009=bsxfun_plus(v006,v008-1);v000(v009(:))=[];<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=test_if_scalar_logical(v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002={true,<span class="keyword">...</span>
false;1,0;<span class="string">'on'</span>,<span class="string">'off'</span>;<span class="string">'enable'</span>,<span class="string">'disable'</span>;<span class="string">'enabled'</span>,<span class="string">'disabled'</span>};<span class="keyword">try</span> v002(end+1,:)=<span class="keyword">...</span>
eval(<span class="string">'{"on","off"}'</span>);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v000=true;<span class="keyword">try</span> <span class="keyword">if</span> isa(v001,<span class="string">'char'</span>) || isa(v001,<span class="string">'string'</span>),<span class="keyword">try</span> <span class="keyword">...</span>
v001=lower(v001);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v003=1:size(v002,1),<span class="keyword">for</span> v004=1:2,<span class="keyword">if</span> isequal(v001,v002{v003,<span class="keyword">...</span>
v004}),v001=v002{1,v004};<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> isa(v001,<span class="string">'matlab.lang.OnOffSwitchState'</span>),v001=<span class="keyword">...</span>
logical(v001);<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">end</span>,v000=false;<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_add_salt(v000,v001),v002=16*numel(v000);v003=v001;
v003.Version=1; v003.HashLength=v002;v003.SkipInputParse=1; v003.isSaltCall=1;v004=<span class="keyword">...</span>
ComputeNonCryptHash(v000,v003);v004=ComputeNonCryptHash_shuffle_uint16_inv(v004);<span class="keyword">if</span> <span class="keyword">...</span>
v001.Version&gt;1,v004=v004(end:-1:1);<span class="keyword">end</span>,v000=mod(double(v000).*double(v004),1+2^16);v000=<span class="keyword">...</span>
uint16(v000);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_dec2hex(v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002=<span class="keyword">...</span>
upper(dec2hex(0:(-1+2^16),4));<span class="keyword">end</span>,v001=double(v001)+1;v000=v002(v001,:);<span class="keyword">end</span>
<span class="keyword">function</span> v000=circshift_by_col(v000),<span class="keyword">persistent</span> v001,v002=size(v000);<span class="keyword">if</span> isempty(v001) || <span class="keyword">...</span>
any(size(v001)&lt;v002) || isempty(v001{v002(1),v002(2)}),[v003,v004]=meshgrid(1:size(v000,2),<span class="keyword">...</span>
1:size(v000,1));v005=mod(v003+v004-2,size(v000,1))+1;v006=sub2ind(size(v000),v005,v003);<span class="keyword">if</span> <span class="keyword">...</span>
prod(v002)&lt;=1000,v001{v002(1),v002(2)}=v006;<span class="keyword">end</span>,<span class="keyword">else</span>,v006=v001{v002(1),v002(2)};<span class="keyword">end</span>,v000=<span class="keyword">...</span>
v000(v006);<span class="keyword">end</span>
<span class="keyword">function</span> v000=TestFolderWritePermission(v001),<span class="keyword">if</span> ~( isempty(v001) || exist(v001,<span class="string">'dir'</span>) ),v000=<span class="keyword">...</span>
false;<span class="keyword">return</span>,<span class="keyword">end</span>,v002=<span class="string">''</span>;<span class="keyword">while</span> isempty(v002) || exist(v002,<span class="string">'file'</span>),[v003,v002]=<span class="keyword">...</span>
fileparts(tmpname(<span class="string">'write_permission_test_'</span>,<span class="string">'.txt'</span>));v002=fullfile(v001,v002);<span class="keyword">end</span>,<span class="keyword">try</span> v004=<span class="keyword">...</span>
fopen(v002,<span class="string">'w'</span>);fprintf(v004,<span class="string">'test'</span>);fclose(v004);delete(v002);v000=true;<span class="keyword">catch</span>,<span class="keyword">if</span> exist(v002,<span class="keyword">...</span>
<span class="string">'file'</span>),<span class="keyword">try</span> delete(v002);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v000=false;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=text2im(v001,v002),<span class="keyword">if</span> nargin&lt;2,v002=<span class="string">'cmu_typewriter_text'</span>;<span class="keyword">end</span>,[v003,v004,v005]=<span class="keyword">...</span>
text2im_load_database(v002);v006=ifversion(<span class="string">'&gt;'</span>,0,<span class="string">'Octave'</span>,<span class="string">'&lt;'</span>,0);<span class="keyword">try</span> v007=cellstr(v001);<span class="keyword">for</span> <span class="keyword">...</span>
v008=1:numel(v007),v009=v007{v008};<span class="keyword">if</span> v006,v009=UTF16_to_unicode(v009);<span class="keyword">else</span>,v009=<span class="keyword">...</span>
UTF8_to_unicode(v009);<span class="keyword">end</span>,v007{v008}=v009;<span class="keyword">end</span>,<span class="keyword">for</span> v008=1:numel(v007),v007{v008}=<span class="keyword">...</span>
char2cellstr(v007{v008});<span class="keyword">end</span>,v007=vertcat(v007{:});<span class="keyword">for</span> v008=1:numel(v007),v007{v008}=<span class="keyword">...</span>
v007{v008}(ismember(v007{v008},v003));<span class="keyword">end</span>,v010=cellfun(<span class="string">'prodofsize'</span>,v007);v011=max(v010);<span class="keyword">for</span> <span class="keyword">...</span>
v008=find(v010&lt;v011).',v007{v008}((end+1):v011)=32;<span class="keyword">end</span>,v001=cell2mat(v007);<span class="keyword">if</span> <span class="keyword">...</span>
~all(ismember(v001,v005(1,:))),error(<span class="string">'invalid char detected'</span>),<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">...</span>
error(<span class="string">'HJW:text2im:InvalidInput'</span>,<span class="keyword">...</span>
[<span class="string">'The input is invalid or contains symbols that are missing in your font.'</span>,char(10),<span class="keyword">...</span>
<span class="string">'(all fonts will have the &lt;127 ASCII characters)'</span>]),<span class="keyword">end</span>,v000=cell2mat(reshape(v004(v001),<span class="keyword">...</span>
size(v001)));<span class="keyword">end</span>
<span class="keyword">function</span> v000=text2im_create_pref_struct(varargin),v000=struct;v001={<span class="string">'CMU Typewriter Text'</span>,<span class="keyword">...</span>
<span class="string">'CMU Concrete'</span>,<span class="string">'ASCII'</span>,<span class="string">'Droid Sans Mono'</span>,<span class="string">'IBM Plex Mono'</span>,<span class="string">'Liberation Mono'</span>,<span class="string">'Monoid'</span>};<span class="keyword">for</span> v002=<span class="keyword">...</span>
1:numel(v001),v000(v002).name=v001{v002};v000(v002).valid_name=strrep(lower(v000(v002).name),<span class="keyword">...</span>
<span class="string">' '</span>,<span class="string">'_'</span>);<span class="keyword">switch</span> v000(v002).valid_name,<span class="keyword">case</span> <span class="string">'cmu_typewriter_text'</span>,v000(v002).url=<span class="keyword">...</span>
[<span class="string">'http://web.archive.org/web/20200418101117im_/'</span>,<span class="keyword">...</span>
<span class="string">'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/'</span>,<span class="keyword">...</span>
<span class="string">'text2im_glyphs_CMU_Typewriter_Text.png'</span>];<span class="keyword">case</span> <span class="string">'cmu_concrete'</span>,v000(v002).url=<span class="keyword">...</span>
[<span class="string">'http://web.archive.org/web/20200418093550im_/'</span>,<span class="keyword">...</span>
<span class="string">'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/'</span>,<span class="string">'text2im_glyphs_CMU_Concrete.png'</span>];
<span class="keyword">case</span> <span class="string">'ascii'</span>,v000(v002).url=[<span class="string">'http://web.archive.org/web/20200418093459im_/'</span>,<span class="keyword">...</span>
<span class="string">'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/'</span>,<span class="string">'text2im_glyphs_ASCII.png'</span>];<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'droid_sans_mono'</span>,v000(v002).url=[<span class="string">'http://web.archive.org/web/20200418093741im_/'</span>,<span class="keyword">...</span>
<span class="string">'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/'</span>,<span class="string">'text2im_glyphs_Droid_Sans_Mono.png'</span>];
<span class="keyword">case</span> <span class="string">'ibm_plex_mono'</span>,v000(v002).url=[<span class="string">'http://web.archive.org/web/20200418093815im_/'</span>,<span class="keyword">...</span>
<span class="string">'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/'</span>,<span class="string">'text2im_glyphs_IBM_Plex_Mono.png'</span>];
<span class="keyword">case</span> <span class="string">'liberation_mono'</span>,v000(v002).url=[<span class="string">'http://web.archive.org/web/20200418093840im_/'</span>,<span class="keyword">...</span>
<span class="string">'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/'</span>,<span class="string">'text2im_glyphs_Liberation_Mono.png'</span>];
<span class="keyword">case</span> <span class="string">'monoid'</span>,v000(v002).url=[<span class="string">'http://web.archive.org/web/20200418093903im_/'</span>,<span class="keyword">...</span>
<span class="string">'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/'</span>,<span class="string">'text2im_glyphs_Monoid.png'</span>];
<span class="keyword">otherwise</span>,v000(v002).url=fullfile(tempdir,[<span class="string">'text2im_glyphs_'</span>,strrep(v001{v002},<span class="string">' '</span>,<span class="string">'_'</span>),<span class="keyword">...</span>
<span class="string">'.png'</span>]);<span class="keyword">end</span>,[v000(v002).printable,v000(v002).glyphs]=text2im__get_glyphs(v000(v002),<span class="keyword">...</span>
varargin{:});<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_logical_to_uint16(v000),<span class="keyword">if</span> mod(numel(v000),16),<span class="keyword">...</span>
v000(16*ceil(numel(v000)/16))=0;<span class="keyword">end</span>,v001=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
<span class="keyword">try</span> v000=v000.*v001;<span class="keyword">catch</span>,v000=double(v000).*repmat(double(v001),[1 size(v000,2)]);v000=<span class="keyword">...</span>
uint16(v000);<span class="keyword">end</span>,v000=uint16(sum(v000,1)).';<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=text2im__get_glyphs(v002,varargin),<span class="keyword">if</span> nargin==1,v003=<span class="keyword">...</span>
text2im__download_IM(v002.url);<span class="keyword">else</span>,v003=[];<span class="keyword">end</span>,<span class="keyword">if</span> isempty(v003),v003=<span class="keyword">...</span>
text2im__get_IM_from_user(v002);<span class="keyword">end</span>,v004=bin2dec(char(<span class="string">'0'</span>+reshape(v003(1,1:60),20,3)'));v005=<span class="keyword">...</span>
(v004(1))*ones(1,ceil(v004(3)/32));v006=(v004(2)+1)*ones(1,32);v007=mat2cell(v003(2:end,:),v005,<span class="keyword">...</span>
v006);v007=v007';v007=v007(1:v004(3));v001=cell(size(v007));v000=zeros(size(v007));v008=max(1,<span class="keyword">...</span>
v004(1)-17);<span class="keyword">for</span> v009=1:numel(v007),v001{v009}=v007{v009}(:,2:end);v000(v009)=<span class="keyword">...</span>
bin2dec(char(<span class="string">'0'</span>+v007{v009}(v008:end,1)'));<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_shuffle_uint16(v000),v001=65537;v002=479001600;v000 = <span class="keyword">...</span>
uint16(mod(double(v000) * v002 , v001));<span class="keyword">end</span>
<span class="keyword">function</span> v000=text2im__download_IM(v001),<span class="keyword">for</span> v002=1:3,<span class="keyword">try</span> v000=imread(v001);<span class="keyword">break</span>,<span class="keyword">catch</span>,v000=[];
<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> isempty(v000),v003=v001(46:end);<span class="keyword">try</span> v000=imread(v003);<span class="keyword">catch</span>,v000=[];<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=typecast_double_uint64(v002),[v003,v004]=log2(v002);v005 =<span class="keyword">...</span>
-floor(sign(v002)/2-0.5);v006=v004+1022;v007=abs(v003)*2-1;v000=zeros(size(v002));v000=<span class="keyword">...</span>
v000+(v005*2^63);v000=v000+(v006*2^52);v000=v000+(v007*2^52);v001=mod(v007*2^52,2^16);v008=<span class="keyword">...</span>
isinf(v002);v000(v002==0)=0;v000(isnan(v002))=18444492273895866368;v000(v008 &amp; v002&gt;0)=<span class="keyword">...</span>
9218868437227405312;v000(v008 &amp; v002&lt;0)=18442240474082181120;v001(v002==0)=0;v001(isnan(v002))=<span class="keyword">...</span>
0;v001(v008)=0;<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=text2im_load_database(v003,varargin),<span class="keyword">persistent</span> v004,<span class="keyword">if</span> nargin&lt;2,v005=<span class="keyword">...</span>
false;<span class="keyword">else</span>,v005=varargin{1};<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;3,v006=false;<span class="keyword">else</span>,v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> v005,v004=[];<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> isempty(v004),v007=fullfile(GetWritableFolder,<span class="string">'FileExchange'</span>,<span class="string">'text2im'</span>,<span class="string">'glyph_database.mat'</span>);
v008=fileparts(v007);<span class="keyword">if</span> ~exist(v008,<span class="string">'dir'</span>),mkdir(v008);<span class="keyword">end</span>,<span class="keyword">if</span> exist(v007,<span class="string">'file'</span>),v009=<span class="keyword">...</span>
load(v007);v010=fieldnames(v009);v004=v009.(v010{1});<span class="keyword">end</span>,<span class="keyword">if</span> v005,v004=[];<span class="keyword">end</span>,<span class="keyword">if</span> isempty(v004),<span class="keyword">...</span>
<span class="keyword">if</span> v006,v004=text2im_create_pref_struct(v006);<span class="keyword">else</span>,v004=text2im_create_pref_struct;<span class="keyword">end</span>,<span class="keyword">...</span>
save(v007,var2str(v004),get_MatFileFlag),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> nargin&gt;0,v011={v004.valid_name};v012=<span class="keyword">...</span>
find(ismember(v011,v003));<span class="keyword">if</span> isempty(v012),warning(<span class="string">'HJW:text2im:IncorrectFontName'</span>,<span class="keyword">...</span>
<span class="string">'Font name doesn''t match any implemented font, reverting to default.'</span>),v012=1;<span class="keyword">end</span>,<span class="keyword">else</span>,v012=1;
<span class="keyword">end</span>,v009=v004(v012);v013=[9 32 160 5760 8192:8202 8239 8287];v014=[10 11 12 13 133 8232 8233];
v015=[173 8203 8204 8205 8288];v016=v009.printable(:)';v001=cell(max(v016),1);v001(v016)=<span class="keyword">...</span>
v009.glyphs;v001(v013)={false(size(v009.glyphs{1}))};v002=[v016 v013 v014 v015;ones(size(v016)),<span class="keyword">...</span>
2*ones(size(v013)),3*ones(size(v014)),4*ones(size(v015))];v000=sort([v016 v013]);<span class="keyword">end</span>
<span class="keyword">function</span> v000=text2im__get_IM_from_user(v001),v002={<span class="string">'Loading of image failed.'</span>,<span class="string">''</span>,<span class="keyword">...</span>
[<span class="string">'You can try again or manually download the image '</span>,<span class="string">'from the URL below.'</span>],<span class="string">''</span>,<span class="keyword">...</span>
[<span class="string">'Once you have downloaded the png, click the button and locate '</span>,<span class="string">'the file.'</span>]};v003=<span class="string">'menu'</span>;<span class="keyword">if</span> <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>),v003=<span class="string">'menubar'</span>;<span class="keyword">end</span>,v004=figure(v003,<span class="string">'none'</span>,<span class="string">'toolbar'</span>,<span class="string">'none'</span>);
uicontrol(<span class="string">'Parent'</span>,v004,<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'Units'</span>,<span class="string">'Normalized'</span>,<span class="string">'Position'</span>,[0.15 0.75 0.70 0.15],<span class="keyword">...</span>
<span class="string">'String'</span>,v002);uicontrol(<span class="string">'Parent'</span>,v004,<span class="string">'style'</span>,<span class="string">'edit'</span>,<span class="string">'Units'</span>,<span class="string">'Normalized'</span>,<span class="string">'Position'</span>,[0.15 0.5 <span class="keyword">...</span>
0.70 0.15],<span class="string">'String'</span>,v001.url);uicontrol(<span class="string">'Parent'</span>,v004,<span class="string">'style'</span>,<span class="string">'pushbutton'</span>,<span class="string">'Units'</span>,<span class="string">'Normalized'</span>,<span class="keyword">...</span>
<span class="string">'Position'</span>,[0.15 0.15 0.70 0.25],<span class="string">'String'</span>,sprintf(<span class="string">'Select the file for: %s'</span>,v001.name),<span class="keyword">...</span>
<span class="string">'Callback'</span>,@text2im__select_png);v005=struct(<span class="string">'f'</span>,v004);guidata(v004,v005),uiwait(v004),v005=<span class="keyword">...</span>
guidata(v004);close(v004),v000=imread(fullfile(v005.path,v005.file));<span class="keyword">end</span>
<span class="keyword">function</span> text2im__select_png(obj,e),v000=guidata(obj);[v000.file,v000.path]=<span class="keyword">...</span>
uigetfile(<span class="string">'text2im_glyphs_*.png'</span>);guidata(obj,v000);uiresume(v000.f);<span class="keyword">end</span>
<span class="keyword">function</span> v000=tmpname(v001,v002),<span class="keyword">if</span> nargin&lt;1,v001=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> ~isempty(v001),v001=[v001 <span class="string">'_'</span>];<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> nargin&lt;2,v002=<span class="string">''</span>;<span class="keyword">else</span>,<span class="keyword">if</span> ~strcmp(v002(1),<span class="string">'.'</span>),v002=[<span class="string">'.'</span> v002];<span class="keyword">end</span>,<span class="keyword">end</span>,v000=tempname;[v003,<span class="keyword">...</span>
v004]=fileparts(v000);v000=fullfile(v003,[v001 v004 v002]);<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_char(v001,v002),<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> nargin==1,v002=~v003;<span class="keyword">end</span>,<span class="keyword">if</span> v002,<span class="keyword">if</span> <span class="keyword">...</span>
all(v001&lt;65536),v000=uint16(v001);v000=reshape(v000,1,numel(v000));<span class="keyword">else</span>,[v004,v005,v006]=<span class="keyword">...</span>
unique(v001);v000=cell(1,numel(v001));<span class="keyword">for</span> v007=1:numel(v004),v008=unicode_to_UTF16(v004(v007));
v008=uint16(v008);v000(v006==v007)={v008};<span class="keyword">end</span>,v000=cell2mat(v000);<span class="keyword">end</span>,<span class="keyword">if</span> ~v003,v000=char(v000);
<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> all(v001&lt;128),v000=char(v001);v000=reshape(v000,1,numel(v000));<span class="keyword">else</span>,[v004,v005,<span class="keyword">...</span>
v006]=unique(v001);v000=cell(1,numel(v001));<span class="keyword">for</span> v007=1:numel(v004),v008=<span class="keyword">...</span>
unicode_to_UTF8(v004(v007));v008=uint8(v008);v000(v006==v007)={v008};<span class="keyword">end</span>,v000=cell2mat(v000);
v000=char(v000);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_UTF16(v001),<span class="keyword">if</span> v001&lt;65536,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,v002=double(v001)-65536;
v002=dec2bin(v002,20);v000=bin2dec([<span class="string">'110110'</span> v002(1:10);<span class="string">'110111'</span> v002(11:20)]).';<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_UTF8(v001),<span class="keyword">if</span> v001&lt;128,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">persistent</span> v002,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v002),v002=struct;v002.limits.lower=hex2dec({<span class="string">'0000'</span>,<span class="string">'0080'</span>,<span class="string">'0800'</span>, <span class="string">'10000'</span>});
v002.limits.upper=hex2dec({<span class="string">'007F'</span>,<span class="string">'07FF'</span>,<span class="string">'FFFF'</span>,<span class="string">'10FFFF'</span>});v002.scheme{2}=<span class="string">'110xxxxx10xxxxxx'</span>;
v002.scheme{2}=reshape(v002.scheme{2}.',8,2);v002.scheme{3}=<span class="string">'1110xxxx10xxxxxx10xxxxxx'</span>;
v002.scheme{3}=reshape(v002.scheme{3}.',8,3);v002.scheme{4}=<span class="string">'11110xxx10xxxxxx10xxxxxx10xxxxxx'</span>;
v002.scheme{4}=reshape(v002.scheme{4}.',8,4);<span class="keyword">for</span> v003=2:4,v002.scheme_pos{v003}=<span class="keyword">...</span>
find(v002.scheme{v003}==<span class="string">'x'</span>);v002.bits(v003)=numel(v002.scheme_pos{v003});<span class="keyword">end</span>,<span class="keyword">end</span>,v004=<span class="keyword">...</span>
find(v002.limits.lower&lt;=v001 &amp; v001&lt;=v002.limits.upper);v000=v002.scheme{v004};v005=<span class="keyword">...</span>
v002.scheme_pos{v004};v003=dec2bin(v001,v002.bits(v004));v000(v005)=v003;v000=bin2dec(v000.').';
<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=UTF8_to_unicode_internal(v000,v003),v001=<span class="string">'success'</span>;v002=<span class="keyword">...</span>
struct(<span class="string">'identifier'</span>,<span class="string">'HJW:UTF8_to_unicode:notUTF8'</span>,<span class="string">'message'</span>,<span class="string">'Input is not UTF-8.'</span>);<span class="keyword">persistent</span> <span class="keyword">...</span>
v004,<span class="keyword">if</span> isempty(v004),v004 = exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> any(v000&gt;255),v001=<span class="keyword">...</span>
<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">elseif</span> all(v000&lt;128),<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v005=4:-1:2,v006=<span class="keyword">...</span>
bin2dec([repmat(<span class="string">'1'</span>,1,v005) repmat(<span class="string">'0'</span>,1,8-v005)]);v007=v000&gt;=v006 &amp; v000&lt;256;<span class="keyword">if</span> any(v007),v007=<span class="keyword">...</span>
find(v007);v007=v007(:).';<span class="keyword">if</span> numel(v000)&lt;(max(v007)+v005-1),v001=<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v007( (v007+v005-1)&gt;numel(v000) )=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isempty(v007),v008=bsxfun_plus(v007 , <span class="keyword">...</span>
(0:(v005-1)).' );v008=v008.';v007=v000(v008);<span class="keyword">end</span>,<span class="keyword">else</span>,v007=[];<span class="keyword">end</span>,v009=[repmat(<span class="string">'1'</span>,1,v005-1) <span class="keyword">...</span>
repmat(<span class="string">'10'</span>,1,v005)];v010=unique([1:(v005+1) 1:8:(8*v005) 2:8:(8*v005)]);<span class="keyword">if</span> numel(v007)&gt;0,v007=<span class="keyword">...</span>
unique(v007,<span class="string">'rows'</span>);v011=mat2cell(v007,ones(size(v007,1),1),v005);<span class="keyword">for</span> v012=1:numel(v011),v013=<span class="keyword">...</span>
dec2bin(double(v011{v012}))';<span class="keyword">if</span> ~strcmp(v009,v013(v010)),v001=<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">continue</span>,<span class="keyword">end</span>,v013(v010)=<span class="string">''</span>;<span class="keyword">if</span> ~v004,v014=uint32(bin2dec(v013 ));<span class="keyword">else</span>,v014=<span class="keyword">...</span>
uint32(bin2dec(v013.'));<span class="keyword">end</span>,v000=PatternReplace(v000,v011{v012},v014);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=UTF16_to_unicode(v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,v001=uint32(v001);v003= v001&gt;55295 &amp; v001&lt;57344;<span class="keyword">if</span> <span class="keyword">...</span>
~any(v003),v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,v004= find( v001&gt;=55296 &amp; v001&lt;=56319 );v005= find( v001&gt;=56320 <span class="keyword">...</span>
&amp; v001&lt;=57343 );<span class="keyword">try</span> v006=v005-v004;<span class="keyword">if</span> any(v006~=1),error(<span class="string">'trigger error'</span>),<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">...</span>
error(<span class="string">'input is not valid UTF-16 encoded'</span>),<span class="keyword">end</span>,v007=<span class="string">'110110110111'</span>;v008=[1:6 17:22];v003=<span class="keyword">...</span>
v001([v004.' v005.']);v003=unique(v003,<span class="string">'rows'</span>);v009=mat2cell(v003,ones(size(v003,1),1),2);v000=<span class="keyword">...</span>
v001;<span class="keyword">for</span> v010=1:numel(v009),v011=dec2bin(double(v009{v010}))';<span class="keyword">if</span> ~strcmp(v007,v011(v008)),<span class="keyword">...</span>
error(<span class="string">'input is not valid UTF-16 encoded'</span>),<span class="keyword">end</span>,v011(v008)=<span class="string">''</span>;<span class="keyword">if</span> ~v002,v012=uint32(bin2dec(v011 <span class="keyword">...</span>
));<span class="keyword">else</span>,v012=uint32(bin2dec(v011.'));<span class="keyword">end</span>,v012=v012+65536;v000=PatternReplace(v000,v009{v010},<span class="keyword">...</span>
v012);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=UTF8_to_unicode(v003,v004),<span class="keyword">if</span> nargin&lt;2,v004=[];<span class="keyword">end</span>,v005= nargout==1 ;
v003=uint32(v003);[v002,v006,v007]=UTF8_to_unicode_internal(v003,v005);<span class="keyword">if</span> strcmp(v006,<span class="keyword">...</span>
<span class="string">'success'</span>),v001=true;v000=v002;<span class="keyword">elseif</span> strcmp(v006,<span class="string">'error'</span>),v001=false;<span class="keyword">if</span> v005,error_(v004,v007),<span class="keyword">...</span>
<span class="keyword">end</span>,v000=v003;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_shuffle_uint16_inv(v000),v001=65537;v002=1919;v000=<span class="keyword">...</span>
uint16(mod(double(v000) * v002,v001));<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_uint16_to_logical(v000),<span class="keyword">persistent</span> v001,<span class="keyword">if</span> isempty(v001),v001=<span class="keyword">...</span>
dec2bin(0:(-1+2^16))==<span class="string">'1'</span>;v001=v001.';<span class="keyword">end</span>,v000=double(v000)+1;v000=v001(:,v000);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_DefaultsByVersion(v000),<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'re_encode_char_on_Octave'</span>),v000.re_encode_char=v000.Version&gt;=2;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'string_to_cellstr'</span>),v000.string_to_cellstr=v000.Version&gt;=2;<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'cast_int64_double'</span>),v000.cast_int64_double=v000.Version==1;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=validate_print_to__options(v002,v001),<span class="keyword">if</span> nargin&lt;2,v001=struct;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isfield(v002,<span class="string">'print_to_con'</span>),v002.print_to_con=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v002,<span class="string">'print_to_fid'</span>),<span class="keyword">...</span>
v002.print_to_fid=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v002,<span class="string">'print_to_obj'</span>),v002.print_to_obj=[];<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isfield(v002,<span class="string">'print_to_fcn'</span>),v002.print_to_fcn=[];<span class="keyword">end</span>,v003=true;v000=struct;v004=<span class="keyword">...</span>
v002.print_to_fid;<span class="keyword">if</span> isempty(v004),v000.boolean.fid=false;<span class="keyword">else</span>,v003=false;v000.boolean.fid=true;
v000.fid=v004;<span class="keyword">for</span> v005=1:numel(v004),<span class="keyword">try</span> v006=ftell(v004(v005));<span class="keyword">catch</span>,v006=-1;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v004(v005)~=1 &amp;&amp; v006==-1,v001.message=[<span class="string">'Invalid print_to_fid parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a valid file identifier or 1.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v004=v002.print_to_obj;<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v004),v000.boolean.obj=false;<span class="keyword">else</span>,v003=false;v000.boolean.obj=true;v000.obj=v004;<span class="keyword">for</span> <span class="keyword">...</span>
v005=1:numel(v004),<span class="keyword">try</span> v007=get(v004(v005),<span class="string">'String'</span> );set( v004(v005),<span class="string">'String'</span>,<span class="string">''</span> );set( <span class="keyword">...</span>
v004(v005),<span class="string">'String'</span>,v007);<span class="keyword">catch</span>,v001.message=[<span class="string">'Invalid print_to_obj parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a handle to an object with a writeable String property.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v004=v002.print_to_fcn;<span class="keyword">if</span> isempty(v004),v000.boolean.fcn=false;<span class="keyword">else</span>,v003=false;<span class="keyword">try</span> <span class="keyword">for</span> v005=<span class="keyword">...</span>
1:numel(v004),<span class="keyword">if</span> ~ismember(class(v004(v005).h),{<span class="string">'function_handle'</span>,<span class="string">'inline'</span>}) || <span class="keyword">...</span>
numel(v004(v005).h)~=1,error(<span class="string">'trigger error'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">catch</span>,v001.message=<span class="keyword">...</span>
[<span class="string">'Invalid print_to_fcn parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a struct with the h field containing a function handle,'</span>,char(10),<span class="keyword">...</span>
<span class="string">'anonymous function or inline function.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v004=v002.print_to_con;<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v004),v000.boolean.con=v003;<span class="keyword">else</span>,[v008,v000.boolean.con]=test_if_scalar_logical(v004);
<span class="keyword">if</span> ~v008,v001.message=[<span class="string">'Invalid print_to_con parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a scalar logical.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> varargout=var2str(varargin),v000= nargin~=max(1,nargout) ;<span class="keyword">if</span> ~v000,varargout=<span class="keyword">...</span>
cell(nargin,1);<span class="keyword">for</span> v001=1:nargin,<span class="keyword">try</span> varargout{v001}=inputname(v001);<span class="keyword">catch</span>,varargout{v001}=<span class="string">''</span>;
<span class="keyword">end</span>,<span class="keyword">if</span> isempty(varargout{v001}),v000=true;<span class="keyword">break</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v000,<span class="keyword">...</span>
error(<span class="string">'Invalid input and/or output.'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> warning_(v001,varargin),<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v000=func2str(@warning_);<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> isempty(v001),v001=struct;<span class="keyword">end</span>,v001=parse_warning_error_redirect_options(v001);[v002,v003,<span class="keyword">...</span>
v004,v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct(<span class="string">'identifier'</span>,v002,<span class="keyword">...</span>
<span class="string">'message'</span>,v003,<span class="string">'stack'</span>,v004);<span class="keyword">if</span> v001.boolean.con,<span class="keyword">if</span> ~isempty(v002),warning(v002,<span class="string">'%s'</span>,v003),<span class="keyword">else</span>,<span class="keyword">...</span>
warning(v003), <span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> ~isempty(v002),lastwarn(v003,v002); <span class="keyword">else</span>,lastwarn(v003),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.boolean.obj,v007=v003;<span class="keyword">while</span> v007(end)==10,v007(end)=[];<span class="keyword">end</span>,<span class="keyword">if</span> any(v007==10),v007=<span class="keyword">...</span>
char2cellstr([<span class="string">'Warning: '</span> v007]);<span class="keyword">else</span>,v007=[<span class="string">'Warning: '</span> v007];<span class="keyword">end</span>,set(v001.obj,<span class="string">'String'</span>,v007),<span class="keyword">...</span>
<span class="keyword">for</span> v008=v001.obj(:).',<span class="keyword">try</span> set(v008,<span class="string">'String'</span>,v007);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid || <span class="keyword">...</span>
v001.boolean.fcn,v009=2;[v005,v004]=get_trace(v009);<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid,<span class="keyword">for</span> v010=<span class="keyword">...</span>
v001.fid(:).',<span class="keyword">try</span> fprintf(v010,<span class="string">'Warning: %s\n%s'</span>,v003,v005);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.boolean.fcn,<span class="keyword">if</span> ismember(v000,{v004.name}),error(<span class="string">'prevent recursion'</span>),<span class="keyword">end</span>,<span class="keyword">for</span> v011=<span class="keyword">...</span>
v001.fcn(:).',<span class="keyword">if</span> isfield(v011,<span class="string">'data'</span>),<span class="keyword">try</span> feval(v011.h,<span class="string">'warning'</span>,v006,v011.data);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
<span class="keyword">try</span> feval(v011.h,<span class="string">'warning'</span>,v006);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% text2im
%
% <html><tt style="font-size:0%">Formatted documentation for the text2im function.</tt>
% <div style="margin-top:-5em;color:grey">Generate an image from text (white text on black background).
% </div>
% </html>

%% Description
% <html>
% This function allows you to convert text to an image. There are several fonts you can pick, each
% with their own character size.
% <br>The list of included characters is based on a relatively arbitrary selection from three
% Wikipedia pages: <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters">general
% characters</a>, <a href="https://en.wikipedia.org/wiki/Newline#Unicode">newline characters</a>,
% and <a href="https://en.wikipedia.org/wiki/Whitespace_character#Unicode>whitespace
% characters</a>.
% <br>The list of actually available characters depends on the chosen font.
% </html>

%% Syntax
%
%   imtext=text2im(text)
%   imtext=text2im(text,font)

%% Output arguments
%
% <html>
% <table border=1>
% <tr><td>
% imtext
% </td><td>
% A char array containing the text image. The size is dependent on the font.
% </td></tr>
% </table>
% </html>

%% Input arguments
%
% <html>
% <table border=1>
% <tr><td>
% text
% </td><td>
% The text to be converted can be supplied as <code>char</code>, <code>string</code>, or
% <code>cellstr</code>. Which characters are allowed is determined by the font. However, all fonts
% contain the printable and blank characters below 127. Any non-standard newline characters are
% ignored (i.e. LF/CR/CRLF are parsed as newline). Non-scalar inputs (or non-row vector inputs in
% the case of <code>char</code>) are allowed, but might not return the desired result.
% </td></tr>
% <tr><td>
% font
% </td><td>
% Font name as char array. Which fonts are available is dictated by the internal
% <code>text2im_load_database</code> function. See the table below for more details and the
% options.
% </td></tr>
% </table>
% </html>

%% Fonts
%
% <html>
% <table border=1>
% <tr><td>
% Font ID
% </td><td>
% Description and license
% </td><td>
% Character size
% </td></tr>
% <tr><td>
% <code>'cmu_typewriter_text'</code>
% </td><td>
% This typeface contains 365 characters. This is a public domain typeface. <a
% href="http://web.archive.org/web/20200418101117im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_CMU_Typewriter_Text.png">[link]</a>
% </td><td>
% <code>size=90x55</code>
% </td></tr>
% <tr><td>
% <code>'cmu_concrete'</code>
% </td><td>
% This typeface contains 364 characters. This is a public domain typeface. <a
% href="http://web.archive.org/web/20200418093550im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_CMU_Concrete.png">[link]</a>
% </td><td>
% <code>size=90x75</code>
% </td></tr>
% <tr><td>
% <code>'ascii'</code>
% </td><td>
% This typeface contains only 94 characters (all printable <code>char</code>s below 127). This
% typeface was previously published in the <code>text2im()</code> (published on the <a
% href="https://www.mathworks.com/matlabcentral/fileexchange/19896">FileExchange</a>
% by Tobias Kiessling). <a
% href="http://web.archive.org/web/20200418093459im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_ASCII.png">[link]</a>
% </td><td>
% <code>size=20x18</code>
% </td></tr>
% <tr><td>
% <code>'droid_sans_mono'</code>
% </td><td>
% This typeface contains 411 characters and has an Apache License (Version 2.0). <a
% href="http://web.archive.org/web/20200418093741im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_Droid_Sans_Mono.png">[link]</a>
% </td><td>
% <code>size=95x51</code>
% </td></tr>
% <tr><td>
% <code>'ibm_plex_mono'</code>
% </td><td>
% This typeface contains 376 characters and has an SIL Open Font License. <a
% href="http://web.archive.org/web/20200418093815im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_IBM_Plex_Mono.png">[link]</a>
% </td><td>
% <code>size=95x51</code>
% </td></tr>
% <tr><td>
% <code>'liberation_mono'</code>
% </td><td>
% This typeface contains 415 characters and has a GNU General Public License. <a
% href="http://web.archive.org/web/20200418093840im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_Liberation_Mono.png">[link]</a>
% </td><td>
% <code>size=95x51</code>
% </td></tr>
% <tr><td>
% <code>'monoid'</code>
% </td><td>
% This typeface contains 398 characters and has an MIT License. <a
% href="http://web.archive.org/web/20200418093903im_/https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/text2im_glyphs_Monoid.png">[link]</a>
% </td><td>
% <code>size=95x51</code>
% </td></tr>
% </table>
% </html>

%% Compatibility, version info, and licence
% <html>
% Compatibility considerations:
% <ul>
%    <li>Multiline inputs may have more trailing blank elements than intended. This is especially
%       true for characters encoded with multiple elements (>127 for Octave and >65535 for
%       Matlab).</li>
% </ul>
% </html>
% 
% <html>
% <table>
% <tr>
% <td> Test suite result </td>
% <td style="border:2px solid black;"> Windows XP/7/10 </td>
% <td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
% <td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2021a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2020b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2020a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2018a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2015a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2013b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2012b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2011a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2010b </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2010a </td>
% <td> <it>W7 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2007b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab 7.1 (R14SP3) </td>
% <td> <it>XP : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab 6.5 (R13) </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 6.2.0 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 5.2.0 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 4.4.1 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% </table>
% </html>
%
%  Version: 1.1.0
%  Date:    2021-05-19
%  Author:  H.J. Wisselink
%  Licence: CC by-nc-sa 4.0 ( https://creativecommons.org/licenses/by-nc-sa/4.0 )
%  Email = 'h_j_wisselink*alumnus_utwente_nl';
%  Real_email = regexprep(Email,{'*','_'},{'@','.'})

%% Test suite
%
% This tester is included so you can test if your own modifications would introduce any bugs. These
% tests form the basis for the compatibility table above.
% 
% Note that some of the functions in this tester might be different from the functions included in
% the actual function. Usually this is done to allow triggering of certain errors.
% 
% To save space, the tester function below was minified. The full tester function (including all comments) can be found <https://web.archive.org/web/20210519084028/https://cdn-123.anonfiles.com/v8c5V3w8u5/3a0eb29e-1621414215/aaa___text2im___test.m here>.

% Compare the output to pre-computed hashes to test exact equivalence
% 
% Pass:    passes all tests
% Partial: [no partial passing condition]
% Fail:    fails any test
%
function v000=aaa___text2im___test(varargin),v000='pass';if nargin==0,v001=false;else,v001=true;
end,if v001,v002='No';else,v002 = questdlg('Test GUI?','','Yes','No','Yes');end,if strcmp(v002,...
'Yes'),v003=true;v004=text2im_load_database('ascii',v003,'trigger GUI');else,v003=true;v004=...
text2im_load_database('ascii',v003);end,v005='The quick brown fox jumped over the lazy dog.';
v006={ 'cmu_typewriter_text','F359E6752670A03B4B80BF9E2FD2FBD9';'cmu_concrete',...
'E93A0D0F023D32DBF3D7A2555D78B825';'ascii','A9D394C668F29F293477DBBDCC0E7877';'droid_sans_mono',...
'262172A9734A48009EAB2E7ACB8D20BD';'ibm_plex_mono','353FA726802F4E99A76BB8FCFC50ECCE';
'liberation_mono','2AE74A75F3F8A93B7021E44F9B96C50F';'monoid',...
'F96E8394C5AFB2412A123D3D05E7DA0E'};v007=size(v006,1);if ~v001,figure(1),clf(1),subplot(v007+1,...
1,1),imshow(text2im(v005)),title('default font'),end,for v008=1:v007,v009=text2im(v005,...
v006{v008,1});v010=ComputeNonCryptHash(v009,128,'-v2');if ~strcmp(v010,v006{v008,2}),...
error('hash of generated image didn''t match hash in library'),end,if ~v001,subplot(v007+1,1,...
v008+1),imshow(v009),title(strrep(v006{v008,1},'_','\_')),end,end,v011=[9 32 160 5760 8192:8202 ...
8239 8287];v012=[10 11 12 13 133 8232 8233];v013=[173 8203 8204 8205 8288];v014=...
unicode_to_char([v011 v012 v013]);try v009=text2im(v014);v010=ComputeNonCryptHash(v009,128,...
'-v2');if ~strcmp(v010,'5A61900CFEC38271667B13E7C768D652'),error('hash comparison failed');end,...
catch,if nargout>0,v000='fail';return,else,error('UTF-8 handling failed'),end,end,try v009=...
text2im({'This will be two lines of the default font.',v005});v010=ComputeNonCryptHash(v009,128,...
'-v2');if ~strcmp(v010,'0EAAFD74F57FE4735F318D4B9A079656'),error('hash comparison failed');end,...
catch,if nargout>0,v000='fail';return,else,error('multiline failed'),end,end,...
disp('test completed'),if nargout==0,clear,end,end
function v000=AddMissing(v001,v000),v002=fieldnames(v001);v003=fieldnames(v000);for v004=...
find(~ismember(v002,v003)).',v005=v002{v004};v000.(v005)=v001.(v005);end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs(varargin),v000=true;v002=struct;
persistent v003,if isempty(v003),v003=struct;v003.HashLength=256;v003.Version=2;
v003.VersionFlag='-v2';v003.SkipInputParse=false;v003.isSaltCall=false;v004=struct;
v003.print_to_con=true;v004.print_to_con=v003.print_to_con;v003.print_to_fid=[];
v004.print_to_fid=v003.print_to_fid;v003.print_to_obj=[];v004.print_to_obj=v003.print_to_obj;
v003.print_to_fcn=[];v004.print_to_fcn=v003.print_to_fcn;v003.print_2__default_options=v004;
v003.print_2__options=validate_print_to__options(v004);end,if nargin==0,v001=...
ComputeNonCryptHash_DefaultsByVersion(v003);return,end,if nargin==1,switch class(varargin{1}),...
case {'char','string'},v001=AddMissing(v003,struct('VersionFlag',char(varargin{1})));case ...
'struct',v001=AddMissing(v003,varargin{1});otherwise,v001=AddMissing(v003,struct('HashLength',...
varargin{1}));end,[v001,v002,v000]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);if ...
v000,v001=ComputeNonCryptHash_DefaultsByVersion(v001);end,return,end,try [v001,v002,v005]=...
ComputeNonCryptHash_parse_inputs__UnwindToStruct( struct,v002,~v000,varargin{:});v000=~v005;
catch,v002.identifier='HJW:ComputeNonCryptHash:InputFail';v002.message=...
'Input parsing failed. Maybe a parameter has been entered twice.';v000=false;end,if ~v000,...
return,else ,v001=AddMissing(v003,v001);end,[v001,v002,v000]=...
ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);if v000,v001=...
ComputeNonCryptHash_DefaultsByVersion(v001);end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v000),v002=true;v001=...
struct;try v003=str2double(v000.VersionFlag(3:end));if isnan(v003) || round(v003)~=v003 || ...
v003>2,error('trigger');end,v000.Version=v003;catch,v001.identifier=...
'HJW:ComputeNonCryptHash:InputIncorrect';v001.message=...
'Version input incorrect. Must be ''-v1'', ''-v2''.';v002=false;return,end,v004=v000.HashLength;
if numel(v004)~=1 || ~isnumeric(v004) || mod(v004,16)~=0 || v004<16,v001.identifier=...
'HJW:ComputeNonCryptHash:InputIncorrect';v001.message=...
'Second input (hash length) must be a multiple of 16.';v002=false;return,end,for v005=...
fieldnames(v000.print_2__default_options),if ~isequal(v000.(v005{1}),...
v000.print_2__default_options.(v005{1})),[v006,v001]=validate_print_to__options(v000);if ...
isempty(v006),v001.identifier='HJW:ComputeNonCryptHash:PrintToIncorrect';v002=false;return,end,...
v000.print_2__options=v006;break,end,end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,...
varargin),if v002 || numel(varargin)==0,return,end,v003=varargin{1};if isa(v003,'struct'),v004=...
fieldnames(v000);v005=fieldnames(v003);v006=unique([v004;v005]);if numel(v004)+numel(v005) ~= ...
numel(v006),v002=true;return,end,v000=AddMissing(v000,v003);varargin(1)=[];elseif isa(v003,...
'char') || isa(v003,'string'),try if isa(v003,'string'),v003=char(v003);end,if strcmpi('-v',...
v003(1:2)),if isfield(v000,'VersionFlag'),error('trigger'),end,v000.VersionFlag=v003;
varargin(1)=[];else,if isfield(v000,v003),error('trigger'),end,v000.(v003)=varargin{2};
varargin(1:2)=[];end,catch,v002=true;return,end,else,if isfield(v000,'HashLength'),v002=true;
return,end,v000.HashLength=v003;varargin(1)=[];end,[v000,v001,v002]=...
ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,varargin{:});end
function v004=get_MatFileFlag,persistent v000,if isempty(v000),v001=exist('OCTAVE_VERSION', ...
'builtin');v002=version;v003=min([numel(v002) strfind(v002,'.')]);v002=...
str2double(v002(1:(v003-1)));if v001 || v002<7,v000='-mat';else,v000='-v6';end,end,v004=v000;end
function [v000,v001]=GetWritableFolder(varargin),[v002,v003,v004]=...
GetWritableFolder_parse_inputs(varargin{:});if ~v002,rethrow(v004),else,[v005,v006,v007]=...
deal(v003.ForceStatus,v003.ErrorOnNotFound,v003.root_folder_list);end,v007{end}=pwd;if v005,...
v001=v005;v000=fullfile(v007{v001},'PersistentFolder');try if ~exist(v000,'dir'),mkdir(v000);
end,catch,end,return,end,v001=1;v000=v007{v001};try if ~exist(v000,'dir'),mkdir(v000);end,catch,...
end,if ~TestFolderWritePermission(v000),v001=2;v000=v007{v001};try if ~exist(v000,'dir'),...
mkdir(v000);end,catch,end,if ~TestFolderWritePermission(v000),v001=3;v000=v007{v001};end,end,...
v000=fullfile(v000,'PersistentFolder');try if ~exist(v000,'dir'),mkdir(v000);end,catch,end,if ...
~TestFolderWritePermission(v000),if v006,error('HJW:GetWritableFolder:NoWritableFolder',...
'This function was unable to find a folder with write permissions.'),else,v001=0;v000='';end,...
end,end
function [v000,v001]=get_trace(v002,v001),if nargin==0,v002=1;end,if nargin<2, v001=dbstack;end,...
v001(1:v002)=[];if ~isfield(v001,'file'),for v003=1:numel(v001),v004=v001(v003).name;if ...
strcmp(v004(end),')'),v005=strfind(v004,'(');v006=v004( (v005(end)+1):(end-1) );v007=...
v004(1:(v005(end)-2));else,v007=v004;[v008,v006]=fileparts(v004);end,[v008,v001(v003).file]=...
fileparts(v007);v001(v003).name=v006;end,end,persistent v009,if isempty(v009),v009=...
exist('OCTAVE_VERSION','builtin');end,if v009,for v003=1:numel(v001),[v008,v001(v003).file]=...
fileparts(v001(v003).file);end,end,v010=v001;v011='>';v000=cell(1,numel(v010)-1);for v003=...
1:numel(v010),[v012,v010(v003).file,v013]=fileparts(v010(v003).file);if v003==numel(v010),...
v010(v003).file='';end,if strcmp(v010(v003).file,v010(v003).name),v010(v003).file='';end,if ...
~isempty(v010(v003).file),v010(v003).file=[v010(v003).file '>'];end,v000{v003}=...
sprintf('%c In %s%s (line %d)\n',v011,v010(v003).file,v010(v003).name,v010(v003).line);v011=' ';
end,v000=horzcat(v000{:});end
function error_(v001,varargin),persistent v000,if isempty(v000),v000=func2str(@error_);end,if ...
isempty(v001),v001=struct;end,v001=parse_warning_error_redirect_options(v001);[v002,v003,v004,...
v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct('identifier',v002,'message',...
v003,'stack',v004);if v001.boolean.obj,v007=v003;while v007(end)==10,v007(end)='';end,if ...
any(v007==10),v007=char2cellstr(['Error: ' v007]);else,v007=['Error: ' v007];end,for v008=...
v001.obj(:).',try set(v008,'String',v007);catch,end,end,end,if v001.boolean.fid,for v009=...
v001.fid(:).',try fprintf(v009,'Error: %s\n%s',v003,v005);catch,end,end,end,if v001.boolean.fcn,...
if ismember(v000,{v004.name}),error('prevent recursion'),end,for v010=v001.fcn(:).',if ...
isfield(v010,'data'),try feval(v010.h,'error',v006,v010.data);catch,end,else,try feval(v010.h,...
'error',v006);catch,end,end,end,end,rethrow(v006),end
function [v000,v001,v002]=GetWritableFolder_parse_inputs(varargin),v000=false;v001=struct;v002=...
struct('identifier','','message','');persistent v003,if isempty(v003),v003.ForceStatus=false;
v003.ErrorOnNotFound=false;v003.root_folder_list={ GetPseudoAddonpath;fullfile(tempdir,...
'MATLAB');''};end,if nargin==2,v001=v003;v000=true;return,end,v004= nargin ==1 && ...
isa(varargin{1},'struct');v005=mod(nargin,2)==0 && all( cellfun('isclass',varargin(1:2:end),...
'char' ) | cellfun('isclass',varargin(1:2:end),'string') );if ~( v004 || v005 ),v002.message=...
['The input is expected to be either a struct, ',char(10),'or consist of Name,Value pairs.'];
v002.identifier='HJW:GetWritableFolder:incorrect_input_options';return,end,if v005,for v006=...
1:2:numel(varargin),try v001.(varargin{v006})=varargin{v006+1};catch,v002.message=...
'Parsing of Name,Value pairs failed.';v002.identifier=...
'HJW:GetWritableFolder:incorrect_input_NameValue';return,end,end,else,v001=varargin{1};end,v007=...
fieldnames(v001);for v008=1:numel(v007),v009=v007{v008};v010=v001.(v009);v002.identifier=...
['HJW:GetWritableFolder:incorrect_input_opt_' lower(v009)];switch v009,case 'ForceStatus',try ...
if ~isa(v003.root_folder_list{v010},'char'),...
error('the indexing must have failed, trigger error'),end,catch,v002.message=...
sprintf('Invalid input: expected a scalar integer between 1 and %d.',...
numel(v003.root_folder_list));return,end,case 'ErrorOnNotFound',[v011,v001.ErrorOnNotFound]=...
test_if_scalar_logical(v010);if ~v011,v002.message=...
'ErrorOnNotFound should be either true or false.';return,end,otherwise,v002.message=...
sprintf('Name,Value pair not recognized: %s.',v009);v002.identifier=...
'HJW:GetWritableFolder:incorrect_input_NameValue';return,end,end,v007=fieldnames(v003);for v008=...
1:numel(v007),if ~isfield(v001,v007(v008)),v001.(v007{v008})=v003.(v007{v008});end,end,v000=...
true;v002=[];end
function v002=GetPseudoAddonpath,if ispc,[v000,v001]=system('echo %APPDATA%');v001(v001<14)='';
v002=fullfile(v001,'MathWorks','MATLAB Add-Ons');else,[v000,v003]=system('echo $HOME');
v003(v003<14)='';v002=fullfile(v003,'Documents','MATLAB','Add-Ons');end,end
function v000=ifversion(v001,v002,v003,v004,v005),persistent v006 v007 v008,if isempty(v006),...
v008=exist('OCTAVE_VERSION', 'builtin');v006=version;v009=strfind(v006,'.');if numel(v009)~=1,...
v006(v009(2):end)='';v009=v009(1);end,v006=[str2double(v006(1:(v009-1))) ...
str2double(v006((v009+1):end))];v006=v006(1)+v006(2)/100;v006=round(100*v006);v007={ 'R13' 605;
'R13SP1' 605;'R13SP2' 605;'R14' 700;'R14SP1' 700;'R14SP2' 700;'R14SP3' 701;'R2006a' 702;
'R2006b' 703;'R2007a' 704;'R2007b' 705;'R2008a' 706;'R2008b' 707;'R2009a' 708;'R2009b' 709;
'R2010a' 710;'R2010b' 711;'R2011a' 712;'R2011b' 713;'R2012a' 714;'R2012b' 800;'R2013a' 801;
'R2013b' 802;'R2014a' 803;'R2014b' 804;'R2015a' 805;'R2015b' 806;'R2016a' 900;'R2016b' 901;
'R2017a' 902;'R2017b' 903;'R2018a' 904;'R2018b' 905;'R2019a' 906;'R2019b' 907;'R2020a' 908;
'R2020b' 909;'R2021a' 910};end,if v008,if nargin==2,warning('HJW:ifversion:NoOctaveTest',...
['No version test for Octave was provided.',char(10),...
'This function might return an unexpected outcome.']),if isnumeric(v002),v010=...
0.1*v002+0.9*fix(v002);v010=round(100*v010);else,v011=ismember(v007(:,1),v002);if sum(v011)~=1,...
warning('HJW:ifversion:NotInDict','The requested version is not in the hard-coded list.'),v000=...
NaN;return,else,v010=v007{v011,2};end,end,elseif nargin==4,[v001,v010]=deal(v003,v004);v010=...
0.1*v010+0.9*fix(v010);v010=round(100*v010);else,[v001,v010]=deal(v004,v005);v010=...
0.1*v010+0.9*fix(v010);v010=round(100*v010);end,else,if isnumeric(v002),v010=...
0.1*v002+0.9*fix(v002);v010=round(100*v010);else,v011=ismember(v007(:,1),v002);if sum(v011)~=1,...
warning('HJW:ifversion:NotInDict','The requested version is not in the hard-coded list.'),v000=...
NaN;return,else,v010=v007{v011,2};end,end,end,switch v001,case '==', v000= v006 == v010;case ...
'<' , v000= v006 < v010;case '<=', v000= v006 <= v010;case '>' , v000= v006 > v010;case '>=', ...
v000= v006 >= v010;end,end
function v000=bsxfun_plus(v001,v002),try v000=v001+v002;catch,try v000=bsxfun(@plus,v001,v002);
catch,v003=size(v001); v004=size(v002);v001=repmat(v001,max(1,v004./v003)); v002=repmat(v002,...
max(1,v003./v004));v000=v001+v002;end,end,end
function [v000,v001,v002,v003]=parse_warning_error_redirect_inputs(varargin),if nargin==1,if ...
isa(varargin{1},'struct') || isa(varargin{1},'MException'),v004=varargin{1};try v002=v004.stack;
v003=get_trace(0,v002);catch,[v003,v002]=get_trace(3);end,v000=v004.identifier;v001=...
v004.message;v005=...
'Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback(';if ...
isa(v004,'struct') && numel(v001)>numel(v005) && strcmp(v005,v001(1:numel(v005))),...
v001(1:find(v001==10,1))='';end,else,[v003,v002]=get_trace(3);[v000,v001]=deal('',varargin{1});
end,else,[v003,v002]=get_trace(3);if ~isempty(strfind(varargin{1},'%')),v000='';v006=...
varargin(2:end);v001=sprintf(varargin{1},v006{:});else,v000=varargin{1};v001=varargin{2};if ...
nargin>3,v006=varargin(3:end);v001=sprintf(v001,v006{:});end,end,end,end
function v000=cast_to_uint16_vector__cell(v000,v001),v002=size(v000).';v000=v000(:);for v003=...
1:numel(v000),if numel(v000{v003})==0,v004=double(class(v000{v003})');v000{v003}=uint16([0;v004;
size(v000{v003})']);continue,end,switch class(v000{v003}),case {'double','single'},v000{v003}=...
cast_to_uint16_vector__floats(v000{v003});case 'logical',v000{v003}=...
cast_to_uint16_vector__logical(v000{v003});case {'uint8','uint16','uint32','uint64','int8',...
'int16','int32','int64'},v000{v003}=cast_to_uint16_vector__integer(v000{v003},v001);case 'char',...
v000{v003}=cast_to_uint16_vector__char(v000{v003},v001);case 'string',v000{v003}=...
cast_to_uint16_vector__string(v000{v003},v001);case 'cell',v000{v003}=...
cast_to_uint16_vector__cell(v000{v003},v001);case 'struct',v000{v003}=...
cast_to_uint16_vector__struct(v000{v003},v001);case {'gpuArray','tall'},v000{v003}=...
cast_to_uint16_vector__cell({gather(v000{v003})},v001);otherwise,error_(v001.print_to,...
'HJW:cast_to_uint16_vector:nosupport','Unsupported data type in nested variable'),end,end,v000=...
cell2mat(v000);v000=[v000;uint16(mod(v002,2^16))];end
function v000=cast_to_uint16_vector__floats(v000),v001=size(v000).';v002=class(v000);[v003,...
v004]=typecast_double_uint64(double(v000));v005=mod(v003,2^16);v003=v003-v005;v003=v003/2^16;
v004=v004.';v006 =mod(v003,2^16);v003=v003-v006; v003=v003/2^16;v006=v006.';v007 =mod(v003,...
2^16);v003=v003-v007; v003=v003/2^16;v007=v007.';v008 =mod(v003,2^16); v008=v008.';v000=[v008;
v007;v006;v004];v000=uint16(v000(:));v000=[v000;uint16(v002.');uint16(mod(v001,2^16))];end
function v000=cast_to_uint16_vector__logical(v000),v001=size(v000).';v000=v000(:);if ...
mod(numel(v000),16),v000(16*ceil(numel(v000)/16))=0;end,v002=uint16(2.^(15:-1:0))';v000=...
uint16(reshape(v000,16,[]));try v000=v000.*v002;catch,v000=double(v000).*repmat(double(v002),[1 ...
size(v000,2)]);v000=uint16(v000);end,v000=uint16(sum(v000,1)).';v000=[v000;uint16(mod(v001,...
2^16))];end
function v000=cast_to_uint16_vector__struct(v000,v001),v002=size(v000).';v000=v000(:);v003=...
fieldnames(v000);v004=cell(2,numel(v003));for v005=1:numel(v003),v004{1,v005}=v003{v005};v004{2,...
v005}={v000.(v003{v005})};end,v000=cast_to_uint16_vector__cell(v004,v001);v000=[v000;
uint16(mod(v002,2^16))];end
function v000=char2cellstr(v001,v002),v003=isa(v001,'char');v001=int32(v001);if nargin<2,if ...
any(v001==13),v001=PatternReplace(v001,int32([13 10]),int32(-10));v001(v001==13)=-10;end,...
v001(v001==10)=-10;else,for v004=1:numel(v002),v001=PatternReplace(v001,int32(v002{v004}),...
int32(-10));end,end,v005=[0 find(v001==-10) numel(v001)+1];v000=cell(numel(v005)-1,1);for v004=...
1:numel(v000),v006=(v005(v004 )+1);v007=(v005(v004+1)-1);v000{v004}=v001(v006:v007);end,if v003,...
for v004=1:numel(v000),v000{v004}= char(v000{v004});end,else,for v004=1:numel(v000),v000{v004}=...
uint32(v000{v004});end,end,end
function v000=ComputeNonCryptHash(v001,varargin),if nargin<1,...
error('HJW:ComputeNonCryptHash:InputIncorrect','At least 1 input required.'),end,if nargin==2 ...
&& isa(varargin{1},'struct') && varargin{1}.SkipInputParse,v002=varargin{1};else,[v003,v002,...
v004]=ComputeNonCryptHash_parse_inputs(varargin{:});if ~v003,rethrow(v004),end,end,...
v002.print_to=v002.print_2__options;v005=v002.HashLength;v006=v002.Version;try v004=[];v001=...
cast_to_uint16_vector(v001,v002);catch v004;if isempty(v004),v004=lasterror;end,if ...
strcmp(v004.identifier,'MATLAB:nomem'),error_(v002.print_to,v004),else,if isfield(v002,'debug') ...
&& v002.debug,v007=sprintf('\n[original error: %s %s]',v004.identifier,v004.message);else,v007=...
'';end,error_(v002.print_to,'HJW:ComputeNonCryptHash:UnwindFailed',...
['The nested input contains an unsupported data type.' v007]),end,end,if mod(numel(v001),...
v005/16),v008=uint16(1:v005/16).'; v008(1:mod(numel(v001),v005/16))=[];v001=[v001;v008];end,if ...
v006==1,v001=ComputeNonCryptHash_shuffle_uint16(v001);v001=...
ComputeNonCryptHash_uint16_to_logical(v001);v001=xor(v001,reshape(v001,[],16).');else,v001=...
ComputeNonCryptHash_shuffle_uint16(v001);v001=ComputeNonCryptHash_uint16_to_logical(v001);v001=...
circshift_by_col(v001);end,v001=mod(sum(reshape(v001,v005,[]),2),2);v001=...
ComputeNonCryptHash_logical_to_uint16(v001);if v002.isSaltCall,v000=v001;return,end,v001=...
ComputeNonCryptHash_add_salt(v001,v002);v000=ComputeNonCryptHash_dec2hex(v001);v000=...
reshape(v000.',1,[]);end
function v000=cast_to_uint16_vector(v000,v001),if isa(v000,'uint16'),v002='uint16';v003=...
size(v000).';v000=reshape(v000,[],1);v000=[v000;uint16(v002.');uint16(mod(v003,2^16))];return,...
end,v000=cast_to_uint16_vector__cell({v000},v001);v000([end-1 end])=[];end
function v000=cast_to_uint16_vector__integer(v000,v001),v002=size(v000).';v000=v000(:);
persistent v003,if isempty(v003),v003=ifversion('>=','R2010b','Octave','>',0);end,v004=...
class(v000);v005=~v001.cast_int64_double && v003 && v004(end)=='4';if ~v005,if ...
any(abs(double(v000(:)))>2^52),warning_(v001,'HJW:ComputeNonCryptHash:int64rounding',...
['int64 and uint64 will be rounded pre-R2010b, resulting in rounding.',char(10),...
'This will result in a hash that is different from newer releases.']),end,end,if v005,if ...
v004(1)~='u',v006=v000>0;v007=-int64(-inf);v008=uint64(v000+v007+1);v008(v006)=...
uint64(v000(v006))+uint64(v007)+1;v000=v008;end,elseif v004(1)~='u',v000=...
double(v000)-double(eval([v004 '(-inf)']));else,v000=double(v000);end,switch v004(end),case '8',...
if mod(numel(v000),2),v000(end+1)=0;end,v000=reshape(v000,[],2);v000=v000(:,1)*255+v000(:,2);
v000=uint16(v000);case '6',v000=uint16(v000);case '2',v009=floor(v000/2^16);v009=v009.';v010=...
mod(v000,2^16); v010=v010.';v000=[v009;v010];v000=uint16(v000(:));case '4',v011=v000;v012=...
mod(v011,2^16);v011=v011-v012;v011=v011/2^16;v012=v012.';v013=mod(v011,2^16);v011=v011-v013;
v011=v011/2^16;v013=v013.';v010=mod(v011,2^16);v011=v011-v010;v011=v011/2^16;v010=v010.';v009=...
mod(v011,2^16); v009=v009.';v000=[v009;v010;v013;v012];v000=uint16(v000(:));end,v000=[v000;
uint16(v004.');uint16(mod(v002,2^16))];end
function v000=cast_to_uint16_vector__string(v000,v001),if v001.string_to_cellstr,v000=...
cellstr(v000);v000=cast_to_uint16_vector__cell(v000,v001);else,v000=char(v000);v000=...
cast_to_uint16_vector__char(v000,v001);end,end
function v000=cast_to_uint16_vector__char(v000,v001),persistent v002,if isempty(v002),v002 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if v002 && v001.re_encode_char,v003 = size(v000,1)==...
numel(v000);if v003,v000=v000.';end,v000=cellstr(v000);for v004=1:numel(v000),v000{v004}=...
unicode_to_char(UTF8_to_unicode(v000{v004},v001.print_to),true);end,v005=cellfun('length',v000);
v006=max(v005);for v004=find(v005<v006),v000{v004}( (numel(v000{v004})+1) : v006)=uint16(' ');
end,v000=cell2mat(v000);if v003,v000=v000.';end,end,v007=size(v000).';v000=v000(:);v000=...
uint16(v000);v000=[v000;uint16(mod(v007,2^16))];end
function v000=parse_warning_error_redirect_options(v000),if ~isfield(v000,'boolean'),...
v000.boolean=struct;end,if ~isfield(v000.boolean,'con') || isempty(v000.boolean.con),...
v000.boolean.con=false;end,if ~isfield(v000.boolean,'fid') || isempty(v000.boolean.fid),...
v000.boolean.fid=isfield(v000,'fid');end,if ~isfield(v000.boolean,'obj') || ...
isempty(v000.boolean.obj),v000.boolean.obj=isfield(v000,'obj');end,if ~isfield(v000.boolean,...
'fcn') || isempty(v000.boolean.fcn),v000.boolean.fcn=isfield(v000,'fcn');end,end
function v000=PatternReplace(v001,v002,v003),v000=v001(:)';if numel(v002)==0,v004=...
false(size(v001));elseif numel(v003)>numel(v002),error('not implemented (padding required)'),...
else,v004=true(size(v001));for v005=1:numel(v002),v006=find(v001==v002(v005));v006=v006-v005+1;
v006(v006<1)=[];v007=false(size(v004));v007(v006)=true;v004= v004 & v007;if ~any(v004),break,...
end,end,end,v006=find(v004);if ~isempty(v006),for v005=1:numel(v003),v000(v006+v005-1)=...
v003(v005);end,if numel(v003)==0,v005=0;end,if numel(v002)>v005,v006=v006(:);v008=...
(v005+1):numel(v002);v009=bsxfun_plus(v006,v008-1);v000(v009(:))=[];end,end,end
function [v000,v001]=test_if_scalar_logical(v001),persistent v002,if isempty(v002),v002={true,...
false;1,0;'on','off';'enable','disable';'enabled','disabled'};try v002(end+1,:)=...
eval('{"on","off"}');catch,end,end,v000=true;try if isa(v001,'char') || isa(v001,'string'),try ...
v001=lower(v001);catch,end,end,for v003=1:size(v002,1),for v004=1:2,if isequal(v001,v002{v003,...
v004}),v001=v002{1,v004};return,end,end,end,if isa(v001,'matlab.lang.OnOffSwitchState'),v001=...
logical(v001);return,end,catch,end,v000=false;end
function v000=ComputeNonCryptHash_add_salt(v000,v001),v002=16*numel(v000);v003=v001;
v003.Version=1; v003.HashLength=v002;v003.SkipInputParse=1; v003.isSaltCall=1;v004=...
ComputeNonCryptHash(v000,v003);v004=ComputeNonCryptHash_shuffle_uint16_inv(v004);if ...
v001.Version>1,v004=v004(end:-1:1);end,v000=mod(double(v000).*double(v004),1+2^16);v000=...
uint16(v000);end
function v000=ComputeNonCryptHash_dec2hex(v001),persistent v002,if isempty(v002),v002=...
upper(dec2hex(0:(-1+2^16),4));end,v001=double(v001)+1;v000=v002(v001,:);end
function v000=circshift_by_col(v000),persistent v001,v002=size(v000);if isempty(v001) || ...
any(size(v001)<v002) || isempty(v001{v002(1),v002(2)}),[v003,v004]=meshgrid(1:size(v000,2),...
1:size(v000,1));v005=mod(v003+v004-2,size(v000,1))+1;v006=sub2ind(size(v000),v005,v003);if ...
prod(v002)<=1000,v001{v002(1),v002(2)}=v006;end,else,v006=v001{v002(1),v002(2)};end,v000=...
v000(v006);end
function v000=TestFolderWritePermission(v001),if ~( isempty(v001) || exist(v001,'dir') ),v000=...
false;return,end,v002='';while isempty(v002) || exist(v002,'file'),[v003,v002]=...
fileparts(tmpname('write_permission_test_','.txt'));v002=fullfile(v001,v002);end,try v004=...
fopen(v002,'w');fprintf(v004,'test');fclose(v004);delete(v002);v000=true;catch,if exist(v002,...
'file'),try delete(v002);catch,end,end,v000=false;end,end
function v000=text2im(v001,v002),if nargin<2,v002='cmu_typewriter_text';end,[v003,v004,v005]=...
text2im_load_database(v002);v006=ifversion('>',0,'Octave','<',0);try v007=cellstr(v001);for ...
v008=1:numel(v007),v009=v007{v008};if v006,v009=UTF16_to_unicode(v009);else,v009=...
UTF8_to_unicode(v009);end,v007{v008}=v009;end,for v008=1:numel(v007),v007{v008}=...
char2cellstr(v007{v008});end,v007=vertcat(v007{:});for v008=1:numel(v007),v007{v008}=...
v007{v008}(ismember(v007{v008},v003));end,v010=cellfun('prodofsize',v007);v011=max(v010);for ...
v008=find(v010<v011).',v007{v008}((end+1):v011)=32;end,v001=cell2mat(v007);if ...
~all(ismember(v001,v005(1,:))),error('invalid char detected'),end,catch,...
error('HJW:text2im:InvalidInput',...
['The input is invalid or contains symbols that are missing in your font.',char(10),...
'(all fonts will have the <127 ASCII characters)']),end,v000=cell2mat(reshape(v004(v001),...
size(v001)));end
function v000=text2im_create_pref_struct(varargin),v000=struct;v001={'CMU Typewriter Text',...
'CMU Concrete','ASCII','Droid Sans Mono','IBM Plex Mono','Liberation Mono','Monoid'};for v002=...
1:numel(v001),v000(v002).name=v001{v002};v000(v002).valid_name=strrep(lower(v000(v002).name),...
' ','_');switch v000(v002).valid_name,case 'cmu_typewriter_text',v000(v002).url=...
['http://web.archive.org/web/20200418101117im_/',...
'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/',...
'text2im_glyphs_CMU_Typewriter_Text.png'];case 'cmu_concrete',v000(v002).url=...
['http://web.archive.org/web/20200418093550im_/',...
'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/','text2im_glyphs_CMU_Concrete.png'];
case 'ascii',v000(v002).url=['http://web.archive.org/web/20200418093459im_/',...
'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/','text2im_glyphs_ASCII.png'];case ...
'droid_sans_mono',v000(v002).url=['http://web.archive.org/web/20200418093741im_/',...
'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/','text2im_glyphs_Droid_Sans_Mono.png'];
case 'ibm_plex_mono',v000(v002).url=['http://web.archive.org/web/20200418093815im_/',...
'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/','text2im_glyphs_IBM_Plex_Mono.png'];
case 'liberation_mono',v000(v002).url=['http://web.archive.org/web/20200418093840im_/',...
'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/','text2im_glyphs_Liberation_Mono.png'];
case 'monoid',v000(v002).url=['http://web.archive.org/web/20200418093903im_/',...
'https://hjwisselink.nl/FEXsubmissiondata/75021-text2im/','text2im_glyphs_Monoid.png'];
otherwise,v000(v002).url=fullfile(tempdir,['text2im_glyphs_',strrep(v001{v002},' ','_'),...
'.png']);end,[v000(v002).printable,v000(v002).glyphs]=text2im__get_glyphs(v000(v002),...
varargin{:});end,end
function v000=ComputeNonCryptHash_logical_to_uint16(v000),if mod(numel(v000),16),...
v000(16*ceil(numel(v000)/16))=0;end,v001=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
try v000=v000.*v001;catch,v000=double(v000).*repmat(double(v001),[1 size(v000,2)]);v000=...
uint16(v000);end,v000=uint16(sum(v000,1)).';end
function [v000,v001]=text2im__get_glyphs(v002,varargin),if nargin==1,v003=...
text2im__download_IM(v002.url);else,v003=[];end,if isempty(v003),v003=...
text2im__get_IM_from_user(v002);end,v004=bin2dec(char('0'+reshape(v003(1,1:60),20,3)'));v005=...
(v004(1))*ones(1,ceil(v004(3)/32));v006=(v004(2)+1)*ones(1,32);v007=mat2cell(v003(2:end,:),v005,...
v006);v007=v007';v007=v007(1:v004(3));v001=cell(size(v007));v000=zeros(size(v007));v008=max(1,...
v004(1)-17);for v009=1:numel(v007),v001{v009}=v007{v009}(:,2:end);v000(v009)=...
bin2dec(char('0'+v007{v009}(v008:end,1)'));end,end
function v000=ComputeNonCryptHash_shuffle_uint16(v000),v001=65537;v002=479001600;v000 = ...
uint16(mod(double(v000) * v002 , v001));end
function v000=text2im__download_IM(v001),for v002=1:3,try v000=imread(v001);break,catch,v000=[];
end,end,if isempty(v000),v003=v001(46:end);try v000=imread(v003);catch,v000=[];end,end,end
function [v000,v001]=typecast_double_uint64(v002),[v003,v004]=log2(v002);v005 =...
-floor(sign(v002)/2-0.5);v006=v004+1022;v007=abs(v003)*2-1;v000=zeros(size(v002));v000=...
v000+(v005*2^63);v000=v000+(v006*2^52);v000=v000+(v007*2^52);v001=mod(v007*2^52,2^16);v008=...
isinf(v002);v000(v002==0)=0;v000(isnan(v002))=18444492273895866368;v000(v008 & v002>0)=...
9218868437227405312;v000(v008 & v002<0)=18442240474082181120;v001(v002==0)=0;v001(isnan(v002))=...
0;v001(v008)=0;end
function [v000,v001,v002]=text2im_load_database(v003,varargin),persistent v004,if nargin<2,v005=...
false;else,v005=varargin{1};end,if nargin<3,v006=false;else,v006=true;end,if v005,v004=[];end,...
if isempty(v004),v007=fullfile(GetWritableFolder,'FileExchange','text2im','glyph_database.mat');
v008=fileparts(v007);if ~exist(v008,'dir'),mkdir(v008);end,if exist(v007,'file'),v009=...
load(v007);v010=fieldnames(v009);v004=v009.(v010{1});end,if v005,v004=[];end,if isempty(v004),...
if v006,v004=text2im_create_pref_struct(v006);else,v004=text2im_create_pref_struct;end,...
save(v007,var2str(v004),get_MatFileFlag),end,end,if nargin>0,v011={v004.valid_name};v012=...
find(ismember(v011,v003));if isempty(v012),warning('HJW:text2im:IncorrectFontName',...
'Font name doesn''t match any implemented font, reverting to default.'),v012=1;end,else,v012=1;
end,v009=v004(v012);v013=[9 32 160 5760 8192:8202 8239 8287];v014=[10 11 12 13 133 8232 8233];
v015=[173 8203 8204 8205 8288];v016=v009.printable(:)';v001=cell(max(v016),1);v001(v016)=...
v009.glyphs;v001(v013)={false(size(v009.glyphs{1}))};v002=[v016 v013 v014 v015;ones(size(v016)),...
2*ones(size(v013)),3*ones(size(v014)),4*ones(size(v015))];v000=sort([v016 v013]);end
function v000=text2im__get_IM_from_user(v001),v002={'Loading of image failed.','',...
['You can try again or manually download the image ','from the URL below.'],'',...
['Once you have downloaded the png, click the button and locate ','the file.']};v003='menu';if ...
exist('OCTAVE_VERSION', 'builtin'),v003='menubar';end,v004=figure(v003,'none','toolbar','none');
uicontrol('Parent',v004,'style','text','Units','Normalized','Position',[0.15 0.75 0.70 0.15],...
'String',v002);uicontrol('Parent',v004,'style','edit','Units','Normalized','Position',[0.15 0.5 ...
0.70 0.15],'String',v001.url);uicontrol('Parent',v004,'style','pushbutton','Units','Normalized',...
'Position',[0.15 0.15 0.70 0.25],'String',sprintf('Select the file for: %s',v001.name),...
'Callback',@text2im__select_png);v005=struct('f',v004);guidata(v004,v005),uiwait(v004),v005=...
guidata(v004);close(v004),v000=imread(fullfile(v005.path,v005.file));end
function text2im__select_png(obj,e),v000=guidata(obj);[v000.file,v000.path]=...
uigetfile('text2im_glyphs_*.png');guidata(obj,v000);uiresume(v000.f);end
function v000=tmpname(v001,v002),if nargin<1,v001='';end,if ~isempty(v001),v001=[v001 '_'];end,...
if nargin<2,v002='';else,if ~strcmp(v002(1),'.'),v002=['.' v002];end,end,v000=tempname;[v003,...
v004]=fileparts(v000);v000=fullfile(v003,[v001 v004 v002]);end
function v000=unicode_to_char(v001,v002),persistent v003,if isempty(v003),v003 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if nargin==1,v002=~v003;end,if v002,if ...
all(v001<65536),v000=uint16(v001);v000=reshape(v000,1,numel(v000));else,[v004,v005,v006]=...
unique(v001);v000=cell(1,numel(v001));for v007=1:numel(v004),v008=unicode_to_UTF16(v004(v007));
v008=uint16(v008);v000(v006==v007)={v008};end,v000=cell2mat(v000);end,if ~v003,v000=char(v000);
end,else,if all(v001<128),v000=char(v001);v000=reshape(v000,1,numel(v000));else,[v004,v005,...
v006]=unique(v001);v000=cell(1,numel(v001));for v007=1:numel(v004),v008=...
unicode_to_UTF8(v004(v007));v008=uint8(v008);v000(v006==v007)={v008};end,v000=cell2mat(v000);
v000=char(v000);end,end,end
function v000=unicode_to_UTF16(v001),if v001<65536,v000=v001;return,end,v002=double(v001)-65536;
v002=dec2bin(v002,20);v000=bin2dec(['110110' v002(1:10);'110111' v002(11:20)]).';end
function v000=unicode_to_UTF8(v001),if v001<128,v000=v001;return,end,persistent v002,if ...
isempty(v002),v002=struct;v002.limits.lower=hex2dec({'0000','0080','0800', '10000'});
v002.limits.upper=hex2dec({'007F','07FF','FFFF','10FFFF'});v002.scheme{2}='110xxxxx10xxxxxx';
v002.scheme{2}=reshape(v002.scheme{2}.',8,2);v002.scheme{3}='1110xxxx10xxxxxx10xxxxxx';
v002.scheme{3}=reshape(v002.scheme{3}.',8,3);v002.scheme{4}='11110xxx10xxxxxx10xxxxxx10xxxxxx';
v002.scheme{4}=reshape(v002.scheme{4}.',8,4);for v003=2:4,v002.scheme_pos{v003}=...
find(v002.scheme{v003}=='x');v002.bits(v003)=numel(v002.scheme_pos{v003});end,end,v004=...
find(v002.limits.lower<=v001 & v001<=v002.limits.upper);v000=v002.scheme{v004};v005=...
v002.scheme_pos{v004};v003=dec2bin(v001,v002.bits(v004));v000(v005)=v003;v000=bin2dec(v000.').';
end
function [v000,v001,v002]=UTF8_to_unicode_internal(v000,v003),v001='success';v002=...
struct('identifier','HJW:UTF8_to_unicode:notUTF8','message','Input is not UTF-8.');persistent ...
v004,if isempty(v004),v004 = exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if any(v000>255),v001=...
'error';if v003,return,end,elseif all(v000<128),return,end,for v005=4:-1:2,v006=...
bin2dec([repmat('1',1,v005) repmat('0',1,8-v005)]);v007=v000>=v006 & v000<256;if any(v007),v007=...
find(v007);v007=v007(:).';if numel(v000)<(max(v007)+v005-1),v001='error';if v003,return,end,...
v007( (v007+v005-1)>numel(v000) )=[];end,if ~isempty(v007),v008=bsxfun_plus(v007 , ...
(0:(v005-1)).' );v008=v008.';v007=v000(v008);end,else,v007=[];end,v009=[repmat('1',1,v005-1) ...
repmat('10',1,v005)];v010=unique([1:(v005+1) 1:8:(8*v005) 2:8:(8*v005)]);if numel(v007)>0,v007=...
unique(v007,'rows');v011=mat2cell(v007,ones(size(v007,1),1),v005);for v012=1:numel(v011),v013=...
dec2bin(double(v011{v012}))';if ~strcmp(v009,v013(v010)),v001='error';if v003,return,end,...
continue,end,v013(v010)='';if ~v004,v014=uint32(bin2dec(v013 ));else,v014=...
uint32(bin2dec(v013.'));end,v000=PatternReplace(v000,v011{v012},v014);end,end,end,end
function v000=UTF16_to_unicode(v001),persistent v002,if isempty(v002),v002 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,v001=uint32(v001);v003= v001>55295 & v001<57344;if ...
~any(v003),v000=v001;return,end,v004= find( v001>=55296 & v001<=56319 );v005= find( v001>=56320 ...
& v001<=57343 );try v006=v005-v004;if any(v006~=1),error('trigger error'),end,catch,...
error('input is not valid UTF-16 encoded'),end,v007='110110110111';v008=[1:6 17:22];v003=...
v001([v004.' v005.']);v003=unique(v003,'rows');v009=mat2cell(v003,ones(size(v003,1),1),2);v000=...
v001;for v010=1:numel(v009),v011=dec2bin(double(v009{v010}))';if ~strcmp(v007,v011(v008)),...
error('input is not valid UTF-16 encoded'),end,v011(v008)='';if ~v002,v012=uint32(bin2dec(v011 ...
));else,v012=uint32(bin2dec(v011.'));end,v012=v012+65536;v000=PatternReplace(v000,v009{v010},...
v012);end,end
function [v000,v001,v002]=UTF8_to_unicode(v003,v004),if nargin<2,v004=[];end,v005= nargout==1 ;
v003=uint32(v003);[v002,v006,v007]=UTF8_to_unicode_internal(v003,v005);if strcmp(v006,...
'success'),v001=true;v000=v002;elseif strcmp(v006,'error'),v001=false;if v005,error_(v004,v007),...
end,v000=v003;end,end
function v000=ComputeNonCryptHash_shuffle_uint16_inv(v000),v001=65537;v002=1919;v000=...
uint16(mod(double(v000) * v002,v001));end
function v000=ComputeNonCryptHash_uint16_to_logical(v000),persistent v001,if isempty(v001),v001=...
dec2bin(0:(-1+2^16))=='1';v001=v001.';end,v000=double(v000)+1;v000=v001(:,v000);end
function v000=ComputeNonCryptHash_DefaultsByVersion(v000),if ~isfield(v000,...
're_encode_char_on_Octave'),v000.re_encode_char=v000.Version>=2;end,if ~isfield(v000,...
'string_to_cellstr'),v000.string_to_cellstr=v000.Version>=2;if ~isfield(v000,...
'cast_int64_double'),v000.cast_int64_double=v000.Version==1;end,end,end
function [v000,v001]=validate_print_to__options(v002,v001),if nargin<2,v001=struct;end,if ...
~isfield(v002,'print_to_con'),v002.print_to_con=[];end,if ~isfield(v002,'print_to_fid'),...
v002.print_to_fid=[];end,if ~isfield(v002,'print_to_obj'),v002.print_to_obj=[];end,if ...
~isfield(v002,'print_to_fcn'),v002.print_to_fcn=[];end,v003=true;v000=struct;v004=...
v002.print_to_fid;if isempty(v004),v000.boolean.fid=false;else,v003=false;v000.boolean.fid=true;
v000.fid=v004;for v005=1:numel(v004),try v006=ftell(v004(v005));catch,v006=-1;end,if ...
v004(v005)~=1 && v006==-1,v001.message=['Invalid print_to_fid parameter:',char(10),...
'should be a valid file identifier or 1.'];v000=[];return,end,end,end,v004=v002.print_to_obj;if ...
isempty(v004),v000.boolean.obj=false;else,v003=false;v000.boolean.obj=true;v000.obj=v004;for ...
v005=1:numel(v004),try v007=get(v004(v005),'String' );set( v004(v005),'String','' );set( ...
v004(v005),'String',v007);catch,v001.message=['Invalid print_to_obj parameter:',char(10),...
'should be a handle to an object with a writeable String property.'];v000=[];return,end,end,end,...
v004=v002.print_to_fcn;if isempty(v004),v000.boolean.fcn=false;else,v003=false;try for v005=...
1:numel(v004),if ~ismember(class(v004(v005).h),{'function_handle','inline'}) || ...
numel(v004(v005).h)~=1,error('trigger error'),end,end,catch,v001.message=...
['Invalid print_to_fcn parameter:',char(10),...
'should be a struct with the h field containing a function handle,',char(10),...
'anonymous function or inline function.'];v000=[];return,end,end,v004=v002.print_to_con;if ...
isempty(v004),v000.boolean.con=v003;else,[v008,v000.boolean.con]=test_if_scalar_logical(v004);
if ~v008,v001.message=['Invalid print_to_con parameter:',char(10),...
'should be a scalar logical.'];v000=[];return,end,end,end
function varargout=var2str(varargin),v000= nargin~=max(1,nargout) ;if ~v000,varargout=...
cell(nargin,1);for v001=1:nargin,try varargout{v001}=inputname(v001);catch,varargout{v001}='';
end,if isempty(varargout{v001}),v000=true;break,end,end,end,if v000,...
error('Invalid input and/or output.'),end,end
function warning_(v001,varargin),persistent v000,if isempty(v000),v000=func2str(@warning_);end,...
if isempty(v001),v001=struct;end,v001=parse_warning_error_redirect_options(v001);[v002,v003,...
v004,v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct('identifier',v002,...
'message',v003,'stack',v004);if v001.boolean.con,if ~isempty(v002),warning(v002,'%s',v003),else,...
warning(v003), end,else,if ~isempty(v002),lastwarn(v003,v002); else,lastwarn(v003),end,end,if ...
v001.boolean.obj,v007=v003;while v007(end)==10,v007(end)=[];end,if any(v007==10),v007=...
char2cellstr(['Warning: ' v007]);else,v007=['Warning: ' v007];end,set(v001.obj,'String',v007),...
for v008=v001.obj(:).',try set(v008,'String',v007);catch,end,end,end,if v001.boolean.fid || ...
v001.boolean.fcn,v009=2;[v005,v004]=get_trace(v009);end,if v001.boolean.fid,for v010=...
v001.fid(:).',try fprintf(v010,'Warning: %s\n%s',v003,v005);catch,end,end,end,if ...
v001.boolean.fcn,if ismember(v000,{v004.name}),error('prevent recursion'),end,for v011=...
v001.fcn(:).',if isfield(v011,'data'),try feval(v011.h,'warning',v006,v011.data);catch,end,else,...
try feval(v011.h,'warning',v006);catch,end,end,end,end,end

##### SOURCE END #####
--></body></html>